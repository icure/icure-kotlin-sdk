{{>licenseInfo}}

package io.icure.kraken.client.infrastructure

import kotlin.reflect.KProperty1
import kotlin.reflect.full.memberProperties

fun <K : Any> K.io.icure.kraken.client.infrastructure.differences(o: K?): List<io.icure.kraken.client.infrastructure.Diff> {
    val self: K = this
    return o?.let { other ->
        if (self is List<*>) {
            (this as List<*>).mapIndexedNotNull { idx, v ->
                when {
                    idx > (other as List<*>).size -> {
                        io.icure.kraken.client.infrastructure.Diff("${idx} <-> missing", listOf())
                    }
                    v != other[idx] -> {
                        io.icure.kraken.client.infrastructure.Diff("${idx} <-> ${idx}", v?.io.icure.kraken.client.infrastructure.differences(other[idx]) ?: listOf())
                    }
                    else -> {
                        null
                    }
                }
            } + if ((other as List<*>).size > (this as List<*>).size) other.takeLast(other.size - this.size)
                .mapIndexed { idx, _ ->
                    io.icure.kraken.client.infrastructure.Diff("missing <-> ${idx + this.size}", listOf())
                } else listOf()
        } else if (self is Set<*>) {
            val notInSelf = (other as Set<*>) - self
            val notInOther = self - (other as Set<*>)

            val othersTreated = mutableSetOf<Any>()

            notInSelf.map { s ->
                io.icure.kraken.client.infrastructure.Diff(
                    "<-",
                    notInOther.map { o -> o to (s?.io.icure.kraken.client.infrastructure.differences(o) ?: listOf()) }.minByOrNull { it.second.size }?.let {
                        it.first?.let { it1 -> othersTreated.add(it1) }
                        it.second.toList()
                    } ?: listOf())
            }.toList() +
                    (notInOther - othersTreated).map { o ->
                        io.icure.kraken.client.infrastructure.Diff("->",
                            notInSelf.map { s -> s?.io.icure.kraken.client.infrastructure.differences(o) ?: listOf() }.minByOrNull { it.size }?.toList()
                                ?: listOf()
                        )
                    }.toList()
        } else if (self is ByteArray) {
            when {
                other !is ByteArray -> {
                    listOf(io.icure.kraken.client.infrastructure.Diff("self"))
                }
                self.size != other.size -> {
                    listOf(io.icure.kraken.client.infrastructure.Diff("self"))
                }
                self.withIndex().any { iv -> iv.value != other[iv.index] } -> self.withIndex()
                    .filter { iv -> iv.value != other[iv.index] }.map { iv ->
                    io.icure.kraken.client.infrastructure.Diff(iv.index.toString())
                }
                else -> listOf()
            }
        } else {
            val props: Collection<KProperty1<Any, *>> = try {
                (this::class).memberProperties as Collection<KProperty1<Any, *>>
            } catch (e: Exception) {
                listOf()
            }
            props.filter {
                try {
                    val selfValue = it.get(self)
                    val otherValue = it.get(other)
                    selfValue != otherValue
                } catch (e: Exception) {
                    false
                }
            }.map { kp ->
                io.icure.kraken.client.infrastructure.Diff(kp.name, kp.get(self)?.let { s -> (s as Any?)?.io.icure.kraken.client.infrastructure.differences((kp.get(other))) } ?: listOf())
            }
        }
    } ?: listOf()
}

data class io.icure.kraken.client.infrastructure.Diff(val propertyName: String, val diffs: List<io.icure.kraken.client.infrastructure.Diff> = listOf()) {
    fun toString(prefix: String = ""): String {
        return "$prefix$propertyName, diffs=\n${diffs.joinToString("\n") { prefix + it.toString("  $prefix") }})"
    }
}
