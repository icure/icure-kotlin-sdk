{{>licenseInfo}}
import io.swagger.client.infrastructure.Serializer
import com.squareup.moshi.JsonAdapter
import java.io.File
import java.io.IOException
import java.util.concurrent.TimeUnit
import kotlin.system.exitProcess
import io.swagger.client.infrastructure.UsernamePassword


class TestUtils {
    companion object {
        val mapAdapter = Serializer.moshi.adapter(Map::class.java)
        var anyAdapter = Serializer.moshi.adapter(Any::class.java)
        val globalParams: Map<String, Any> = mapAdapter.fromJson(this::class.java.classLoader.getResource("parameters/Global.json").readText()) as Map<String, Any>

        inline fun <reified T> getParameter(fileName: String, name: String): T? {
            val paramElements = name.split(".")
            val localParams = mapAdapter.fromJson(this::class.java.classLoader.getResource("parameters/$fileName").readText())
            val tJsonAdapter: JsonAdapter<T> = Serializer.moshi.adapter(T::class.java)

            return localParams?.let {
                val methodParams: Map<String, Any>? = localParams[paramElements[0]] as Map<String, Any>?
                methodParams?.let {
                    when(T::class){
                        Long::class -> (methodParams[paramElements[1]] as Double?)?.toLong() as T? ?:  (getGlobalParam(paramElements[1]) as Double?)?.toLong() as T?
                        else -> tJsonAdapter.fromJson(anyAdapter.toJson(methodParams[paramElements[1]])) ?: getGlobalObjectParam(tJsonAdapter, paramElements[1])
                    }
                }
            }
        }

        inline fun <reified T> getParameters(fileName: String, name: String): kotlin.collections.List<T?>? {
            val paramElements = name.split(".")
            val localParams = mapAdapter.fromJson(this::class.java.classLoader.getResource("parameters/$fileName").readText())
            val tJsonAdapter: JsonAdapter<T> = Serializer.moshi.adapter(T::class.java)

                return localParams?.let {
                    val methodParams: Map<String, List<*>>? = localParams[paramElements[0]] as Map<String, List<*>>?
                    methodParams?.let {
                        methodParams[paramElements[1]]
                            ?.map { tJsonAdapter.fromJson(anyAdapter.toJson(it)) }
                            ?.toList()
                    }
                }
        }

        inline fun <reified T> getGlobalObjectParam(tJsonAdapter: JsonAdapter<T>,globalParam: String ): T?{
            for ((k, v) in globalParams) {
                if (globalParam.endsWith(k)) {
                    return tJsonAdapter.fromJson(anyAdapter.toJson(v))
                }
            }
            return null
        }

        inline fun getGlobalParam(globalParam: String): Any? {
            for ((k, v) in globalParams) {
                if (globalParam.endsWith(k)) {
                    return v
                }
            }
            return null
        }

		fun isAutoRev(parmatersFileName: String, callingFunctionName: String): Boolean {
			val isAutoRev  = getParameter<Boolean>(parmatersFileName, "$callingFunctionName.autoRev")
			return isAutoRev ?: false
		}

		fun skipEndpoint(parmatersFileName: String, callingFunctionName: String): Boolean {
			val skipEndpoint  = getParameter<Boolean>(parmatersFileName, "$callingFunctionName.skipEndpoint")
			return skipEndpoint ?: false
		}

        fun getCredentialsFile(parmatersFileName: String, callingFunctionName: String): String {
            val credentialsFileFromParametersFile  = getParameter<String>(parmatersFileName, "$callingFunctionName.credentialsFile")
            return credentialsFileFromParametersFile ?: infereCredentialsFile(callingFunctionName)
        }

		fun deleteAfterElements(parametersFileName: String) {
			val callingFunctionName = "afterElements"
			val usernamePassword = Serializer.moshi.adapter(UsernamePassword::class.java).fromJson(File(".credentialsCouchDb").readText())!!
			val u = usernamePassword.username
			val p = usernamePassword.password
			val family  = getParameter<String>(parametersFileName, "$callingFunctionName.family")
			val ids  = getParameter<List<String>>(parametersFileName, "$callingFunctionName.deleteIds")
			if (family != null && ids != null) {
				ids.forEach {
					val command = "id=\"$it\"; rev=$(curl -s -X GET https://$u:$p@couch.svcacc.icure.cloud/icure-test-2-tz-dev-team-$family/\$id | jq -r '._rev') && curl -s -X DELETE \"https://$u:$p@couch.svcacc.icure.cloud/icure-test-2-tz-dev-team-$family/\$id?rev=\$rev\""
					println(command)
					command.runCommand()
				}
			}
		}

        private fun infereCredentialsFile(callingFunctionName: String): String {
            return when {
                callingFunctionName.startsWith("new") -> {
                    ".credentialsReadWrite"
                }
                callingFunctionName.startsWith("delete") -> {
                    ".credentialsReadWrite"
                }
                callingFunctionName.startsWith("create") -> {
                    ".credentialsReadWrite"
                }
                callingFunctionName.startsWith("modify") -> {
                    ".credentialsReadWrite"
                }
                callingFunctionName.startsWith("set") -> {
                    ".credentialsReadWrite"
                }
                else -> {
                    ".credentialsReadOnly"
                }
            }
        }

        fun String.runCommandExitStatus(path: String = ".", streamOutput: Boolean = true, checkReturnValue: Boolean = true, variables: Map<String, String> = mapOf(), suicideOnFailure: Boolean = false): Pair<String, Int> {
            val output = if (streamOutput) ProcessBuilder.Redirect.INHERIT else ProcessBuilder.Redirect.PIPE
            try {
                val workingDir = File(path)
                val parts = listOf("sh", "-c", this)
                val proc = ProcessBuilder(*parts.toTypedArray())
                    .directory(workingDir)
                    .redirectErrorStream(true)
                    .redirectOutput(output)
                    .also {
                        val env = it.environment()
                        variables.forEach { (name, value) ->
                            env[name] = value
                        }
                    }
                    .start()
                val result = proc.inputStream.bufferedReader().readText().trim()
                if (!proc.waitFor(60, TimeUnit.MINUTES)) throw UnsupportedOperationException("Failed executing command $this: waitFor returned false")
                if (checkReturnValue && proc.exitValue() != 0) println("Process exit value ${proc.exitValue()}, command was '$this', result was '$result'")
                if (suicideOnFailure && proc.exitValue() != 0) exitProcess(1)
                return Pair(result, proc.exitValue())
            } catch (e: IOException) {
                throw UnsupportedOperationException("Failed executing command $this: $e")
            }
        }

        fun String.runCommand(path: String = ".", streamOutput: Boolean = true, checkReturnValue: Boolean = true, variables: Map<String, String> = mapOf(), suicideOnFailure: Boolean = false) =
            runCommandExitStatus(path, streamOutput, checkReturnValue, variables, suicideOnFailure).first
    }
}
