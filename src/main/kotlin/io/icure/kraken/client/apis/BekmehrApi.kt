/**
 * iCure Data Stack API Documentation
 *
 * The iCure Data Stack Application API is the native interface to iCure.
 *
 * The version of the OpenAPI document: v2
 *
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
package io.icure.kraken.client.apis

import io.icure.asyncjacksonhttpclient.net.web.WebClient
import io.icure.asyncjacksonhttpclient.netty.NettyWebClient
import io.icure.kraken.client.infrastructure.*
import io.icure.kraken.client.models.CheckSMFPatientResult
import io.icure.kraken.client.models.DiaryNoteExportInfoDto
import io.icure.kraken.client.models.ImportMapping
import io.icure.kraken.client.models.IncapacityExportInfoDto
import io.icure.kraken.client.models.MedicationSchemeExportInfoDto
import io.icure.kraken.client.models.SoftwareMedicalFileExportDto
import io.icure.kraken.client.models.SumehrContentDto
import io.icure.kraken.client.models.SumehrExportInfoDto
import io.icure.kraken.client.models.SumehrValidityDto
import io.icure.kraken.client.security.AuthProvider
import io.icure.kraken.client.security.NoAuthProvider
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.taktik.icure.services.external.rest.v2.dto.ImportResultDto
import org.taktik.icure.services.external.rest.v2.dto.embed.ContentDto
import java.net.URLEncoder
import java.util.*
import javax.inject.Named

@Named
@ExperimentalStdlibApi
@ExperimentalCoroutinesApi
class BekmehrApi(
    basePath: String = defaultBasePath,
    webClient: WebClient = NettyWebClient(),
    authProvider: AuthProvider = NoAuthProvider()
) : ApiClient(basePath, webClient, authProvider) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("io.icure.kraken.client.baseUrl", "https://kraken.icure.dev")
        }
    }

    /**
     * Check whether patients in SMF already exists in DB
     *
     * @param documentId
     * @param documentKey  (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @param requestBody  (optional)
     * @return kotlin.collections.List<CheckSMFPatientResult>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun checkIfSMFPatientsExists(
        documentId: String,
        documentKey: String?,
        patientId: String?,
        language: String?,
        requestBody: Map<String, List<ImportMapping>>?
    ): List<CheckSMFPatientResult> {
        val localVariableConfig = checkIfSMFPatientsExistsRequestConfig(
            documentId = documentId,
            documentKey = documentKey,
            patientId = patientId,
            language = language,
            requestBody = requestBody
        )

        return request<Map<String, List<ImportMapping>>, List<CheckSMFPatientResult>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation checkIfSMFPatientsExists
     *
     * @param documentId
     * @param documentKey  (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @param requestBody  (optional)
     * @return RequestConfig
     */
    fun checkIfSMFPatientsExistsRequestConfig(
        documentId: String,
        documentKey: String?,
        patientId: String?,
        language: String?,
        requestBody: Map<String, List<ImportMapping>>?
    ): RequestConfig<Map<String, List<ImportMapping>>> {
        // val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (documentKey != null) {
                    put("documentKey", listOf(documentKey.toString()))
                }
                if (patientId != null) {
                    put("patientId", listOf(patientId))
                }
                if (language != null) {
                    put("language", listOf(language))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = requestBody

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/smf/{documentId}/checkIfSMFPatientsExists".replace(
                "{" + "documentId" + "}",
                URLEncoder.encode(documentId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Kmehr contactreport
     *
     * @param patientId
     * @param id
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param body
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun generateContactreportExport(
        patientId: String,
        id: String,
        date: Long,
        language: String,
        recipientNihii: String,
        recipientSsin: String,
        recipientFirstName: String,
        recipientLastName: String,
        mimeType: String,
        body: kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = generateContactreportExportRequestConfig(
            patientId = patientId,
            id = id,
            date = date,
            language = language,
            recipientNihii = recipientNihii,
            recipientSsin = recipientSsin,
            recipientFirstName = recipientFirstName,
            recipientLastName = recipientLastName,
            mimeType = mimeType,
            body = body
        )

        return request<kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation generateContactreportExport
     *
     * @param patientId
     * @param id
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param body
     * @return RequestConfig
     */
    fun generateContactreportExportRequestConfig(
        patientId: String,
        id: String,
        date: Long,
        language: String,
        recipientNihii: String,
        recipientSsin: String,
        recipientFirstName: String,
        recipientLastName: String,
        mimeType: String,
        body: kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
    ): RequestConfig<kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>> {
        // val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("date", listOf(date.toString()))
                put("language", listOf(language))
                put("recipientNihii", listOf(recipientNihii))
                put("recipientSsin", listOf(recipientSsin))
                put("recipientFirstName", listOf(recipientFirstName))
                put("recipientLastName", listOf(recipientLastName))
                put("mimeType", listOf(mimeType))
            }
        val localVariableHeaders: MutableMap<String, String> =
            mutableMapOf("Content-Type" to "application/octet-stream")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = body

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/contactreport/{patientId}/export/{id}".replace(
                "{" + "patientId" + "}",
                URLEncoder.encode(patientId, Charsets.UTF_8)
            ).replace("{" + "id" + "}", URLEncoder.encode(id, Charsets.UTF_8)),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Generate diarynote
     *
     * @param patientId
     * @param language
     * @param diaryNoteExportInfoDto
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun generateDiaryNote(
        patientId: String,
        language: String,
        diaryNoteExportInfoDto: DiaryNoteExportInfoDto
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = generateDiaryNoteRequestConfig(
            patientId = patientId,
            language = language,
            diaryNoteExportInfoDto = diaryNoteExportInfoDto
        )

        return request<DiaryNoteExportInfoDto, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation generateDiaryNote
     *
     * @param patientId
     * @param language
     * @param diaryNoteExportInfoDto
     * @return RequestConfig
     */
    fun generateDiaryNoteRequestConfig(
        patientId: String,
        language: String,
        diaryNoteExportInfoDto: DiaryNoteExportInfoDto
    ): RequestConfig<DiaryNoteExportInfoDto> {
        // val localVariableBody = diaryNoteExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("language", listOf(language))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = diaryNoteExportInfoDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/diarynote/{patientId}/export".replace(
                "{" + "patientId" + "}",
                URLEncoder.encode(patientId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Incapacity export
     *
     * @param patientId
     * @param language
     * @param incapacityExportInfoDto
     * @param xTimezoneOffset  (optional)
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun generateIncapacityExport(
        patientId: String,
        language: String,
        incapacityExportInfoDto: IncapacityExportInfoDto,
        xTimezoneOffset: String?
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = generateIncapacityExportRequestConfig(
            patientId = patientId,
            language = language,
            incapacityExportInfoDto = incapacityExportInfoDto,
            xTimezoneOffset = xTimezoneOffset
        )

        return request<IncapacityExportInfoDto, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation generateIncapacityExport
     *
     * @param patientId
     * @param language
     * @param incapacityExportInfoDto
     * @param xTimezoneOffset  (optional)
     * @return RequestConfig
     */
    fun generateIncapacityExportRequestConfig(
        patientId: String,
        language: String,
        incapacityExportInfoDto: IncapacityExportInfoDto,
        xTimezoneOffset: String?
    ): RequestConfig<IncapacityExportInfoDto> {
        // val localVariableBody = incapacityExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("language", listOf(language))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = incapacityExportInfoDto
        xTimezoneOffset?.apply { localVariableHeaders["X-Timezone-Offset"] = this }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/incapacity/{patientId}/export".replace(
                "{" + "patientId" + "}",
                URLEncoder.encode(patientId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Kmehr labresult
     *
     * @param patientId
     * @param id
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param body
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun generateLabresultExport(
        patientId: String,
        id: String,
        date: Long,
        language: String,
        recipientNihii: String,
        recipientSsin: String,
        recipientFirstName: String,
        recipientLastName: String,
        mimeType: String,
        body: kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = generateLabresultExportRequestConfig(
            patientId = patientId,
            id = id,
            date = date,
            language = language,
            recipientNihii = recipientNihii,
            recipientSsin = recipientSsin,
            recipientFirstName = recipientFirstName,
            recipientLastName = recipientLastName,
            mimeType = mimeType,
            body = body
        )

        return request<kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation generateLabresultExport
     *
     * @param patientId
     * @param id
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param body
     * @return RequestConfig
     */
    fun generateLabresultExportRequestConfig(
        patientId: String,
        id: String,
        date: Long,
        language: String,
        recipientNihii: String,
        recipientSsin: String,
        recipientFirstName: String,
        recipientLastName: String,
        mimeType: String,
        body: kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
    ): RequestConfig<kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>> {
        // val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("date", listOf(date.toString()))
                put("language", listOf(language))
                put("recipientNihii", listOf(recipientNihii))
                put("recipientSsin", listOf(recipientSsin))
                put("recipientFirstName", listOf(recipientFirstName))
                put("recipientLastName", listOf(recipientLastName))
                put("mimeType", listOf(mimeType))
            }
        val localVariableHeaders: MutableMap<String, String> =
            mutableMapOf("Content-Type" to "application/octet-stream")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = body

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/labresult/{patientId}/export/{id}".replace(
                "{" + "patientId" + "}",
                URLEncoder.encode(patientId, Charsets.UTF_8)
            ).replace("{" + "id" + "}", URLEncoder.encode(id, Charsets.UTF_8)),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Medicationscheme export
     *
     * @param patientId
     * @param language
     * @param recipientSafe
     * @param version
     * @param medicationSchemeExportInfoDto
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun generateMedicationSchemeExport(
        patientId: String,
        language: String,
        recipientSafe: String,
        version: Int,
        medicationSchemeExportInfoDto: MedicationSchemeExportInfoDto
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = generateMedicationSchemeExportRequestConfig(
            patientId = patientId,
            language = language,
            recipientSafe = recipientSafe,
            version = version,
            medicationSchemeExportInfoDto = medicationSchemeExportInfoDto
        )

        return request<MedicationSchemeExportInfoDto, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation generateMedicationSchemeExport
     *
     * @param patientId
     * @param language
     * @param recipientSafe
     * @param version
     * @param medicationSchemeExportInfoDto
     * @return RequestConfig
     */
    fun generateMedicationSchemeExportRequestConfig(
        patientId: String,
        language: String,
        recipientSafe: String,
        version: Int,
        medicationSchemeExportInfoDto: MedicationSchemeExportInfoDto
    ): RequestConfig<MedicationSchemeExportInfoDto> {
        // val localVariableBody = medicationSchemeExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("language", listOf(language))
                put("recipientSafe", listOf(recipientSafe))
                put("version", listOf(version.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = medicationSchemeExportInfoDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/medicationscheme/{patientId}/export".replace(
                "{" + "patientId" + "}",
                URLEncoder.encode(patientId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Kmehr note
     *
     * @param patientId
     * @param id
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param body
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun generateNoteExport(
        patientId: String,
        id: String,
        date: Long,
        language: String,
        recipientNihii: String,
        recipientSsin: String,
        recipientFirstName: String,
        recipientLastName: String,
        mimeType: String,
        body: kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = generateNoteExportRequestConfig(
            patientId = patientId,
            id = id,
            date = date,
            language = language,
            recipientNihii = recipientNihii,
            recipientSsin = recipientSsin,
            recipientFirstName = recipientFirstName,
            recipientLastName = recipientLastName,
            mimeType = mimeType,
            body = body
        )

        return request<kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation generateNoteExport
     *
     * @param patientId
     * @param id
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param body
     * @return RequestConfig
     */
    fun generateNoteExportRequestConfig(
        patientId: String,
        id: String,
        date: Long,
        language: String,
        recipientNihii: String,
        recipientSsin: String,
        recipientFirstName: String,
        recipientLastName: String,
        mimeType: String,
        body: kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
    ): RequestConfig<kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>> {
        // val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("date", listOf(date.toString()))
                put("language", listOf(language))
                put("recipientNihii", listOf(recipientNihii))
                put("recipientSsin", listOf(recipientSsin))
                put("recipientFirstName", listOf(recipientFirstName))
                put("recipientLastName", listOf(recipientLastName))
                put("mimeType", listOf(mimeType))
            }
        val localVariableHeaders: MutableMap<String, String> =
            mutableMapOf("Content-Type" to "application/octet-stream")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = body

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/note/{patientId}/export/{id}".replace(
                "{" + "patientId" + "}",
                URLEncoder.encode(patientId, Charsets.UTF_8)
            ).replace("{" + "id" + "}", URLEncoder.encode(id.toString(), Charsets.UTF_8)),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get KMEHR Patient Info export
     *
     * @param patientId
     * @param language  (optional)
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun generatePatientInfoExport(
        patientId: String,
        language: String?
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = generatePatientInfoExportRequestConfig(patientId = patientId, language = language)

        return request<Unit, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation generatePatientInfoExport
     *
     * @param patientId
     * @param language  (optional)
     * @return RequestConfig
     */
    fun generatePatientInfoExportRequestConfig(
        patientId: String,
        language: String?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (language != null) {
                    put("language", listOf(language))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/patientinfo/{patientId}/export".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Kmehr prescription
     *
     * @param patientId
     * @param id
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param body
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun generatePrescriptionExport(
        patientId: String,
        id: String,
        date: Long,
        language: String,
        recipientNihii: String,
        recipientSsin: String,
        recipientFirstName: String,
        recipientLastName: String,
        mimeType: String,
        body: kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = generatePrescriptionExportRequestConfig(
            patientId = patientId,
            id = id,
            date = date,
            language = language,
            recipientNihii = recipientNihii,
            recipientSsin = recipientSsin,
            recipientFirstName = recipientFirstName,
            recipientLastName = recipientLastName,
            mimeType = mimeType,
            body = body
        )

        return request<kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation generatePrescriptionExport
     *
     * @param patientId
     * @param id
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param body
     * @return RequestConfig
     */
    fun generatePrescriptionExportRequestConfig(
        patientId: String,
        id: String,
        date: Long,
        language: String,
        recipientNihii: String,
        recipientSsin: String,
        recipientFirstName: String,
        recipientLastName: String,
        mimeType: String,
        body: kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
    ): RequestConfig<kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>> {
        // val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("date", listOf(date.toString()))
                put("language", listOf(language))
                put("recipientNihii", listOf(recipientNihii))
                put("recipientSsin", listOf(recipientSsin))
                put("recipientFirstName", listOf(recipientFirstName))
                put("recipientLastName", listOf(recipientLastName))
                put("mimeType", listOf(mimeType))
            }
        val localVariableHeaders: MutableMap<String, String> =
            mutableMapOf("Content-Type" to "application/octet-stream")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = body

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/prescription/{patientId}/export/{id}".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ).replace("{" + "id" + "}", "${URLEncoder.encode(id.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Kmehr report
     *
     * @param patientId
     * @param id
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param body
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun generateReportExport(
        patientId: String,
        id: String,
        date: Long,
        language: String,
        recipientNihii: String,
        recipientSsin: String,
        recipientFirstName: String,
        recipientLastName: String,
        mimeType: String,
        body: kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = generateReportExportRequestConfig(
            patientId = patientId,
            id = id,
            date = date,
            language = language,
            recipientNihii = recipientNihii,
            recipientSsin = recipientSsin,
            recipientFirstName = recipientFirstName,
            recipientLastName = recipientLastName,
            mimeType = mimeType,
            body = body
        )

        return request<kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation generateReportExport
     *
     * @param patientId
     * @param id
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param body
     * @return RequestConfig
     */
    fun generateReportExportRequestConfig(
        patientId: String,
        id: String,
        date: Long,
        language: String,
        recipientNihii: String,
        recipientSsin: String,
        recipientFirstName: String,
        recipientLastName: String,
        mimeType: String,
        body: kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
    ): RequestConfig<kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>> {
        // val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("date", listOf(date.toString()))
                put("language", listOf(language))
                put("recipientNihii", listOf(recipientNihii))
                put("recipientSsin", listOf(recipientSsin))
                put("recipientFirstName", listOf(recipientFirstName))
                put("recipientLastName", listOf(recipientLastName))
                put("mimeType", listOf(mimeType))
            }
        val localVariableHeaders: MutableMap<String, String> =
            mutableMapOf("Content-Type" to "application/octet-stream")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = body

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/report/{patientId}/export/{id}".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ).replace("{" + "id" + "}", "${URLEncoder.encode(id.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Kmehr request
     *
     * @param patientId
     * @param id
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param body
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun generateRequestExport(
        patientId: String,
        id: String,
        date: Long,
        language: String,
        recipientNihii: String,
        recipientSsin: String,
        recipientFirstName: String,
        recipientLastName: String,
        mimeType: String,
        body: kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = generateRequestExportRequestConfig(
            patientId = patientId,
            id = id,
            date = date,
            language = language,
            recipientNihii = recipientNihii,
            recipientSsin = recipientSsin,
            recipientFirstName = recipientFirstName,
            recipientLastName = recipientLastName,
            mimeType = mimeType,
            body = body
        )

        return request<kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation generateRequestExport
     *
     * @param patientId
     * @param id
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param body
     * @return RequestConfig
     */
    fun generateRequestExportRequestConfig(
        patientId: String,
        id: String,
        date: Long,
        language: String,
        recipientNihii: String,
        recipientSsin: String,
        recipientFirstName: String,
        recipientLastName: String,
        mimeType: String,
        body: kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
    ): RequestConfig<kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>> {
        // val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("date", listOf(date.toString()))
                put("language", listOf(language))
                put("recipientNihii", listOf(recipientNihii))
                put("recipientSsin", listOf(recipientSsin))
                put("recipientFirstName", listOf(recipientFirstName))
                put("recipientLastName", listOf(recipientLastName))
                put("mimeType", listOf(mimeType))
            }
        val localVariableHeaders: MutableMap<String, String> =
            mutableMapOf("Content-Type" to "application/octet-stream")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = body

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/request/{patientId}/export/{id}".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ).replace("{" + "id" + "}", "${URLEncoder.encode(id.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Kmehr result
     *
     * @param patientId
     * @param id
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param body
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun generateResultExport(
        patientId: String,
        id: String,
        date: Long,
        language: String,
        recipientNihii: String,
        recipientSsin: String,
        recipientFirstName: String,
        recipientLastName: String,
        mimeType: String,
        body: kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = generateResultExportRequestConfig(
            patientId = patientId,
            id = id,
            date = date,
            language = language,
            recipientNihii = recipientNihii,
            recipientSsin = recipientSsin,
            recipientFirstName = recipientFirstName,
            recipientLastName = recipientLastName,
            mimeType = mimeType,
            body = body
        )

        return request<kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation generateResultExport
     *
     * @param patientId
     * @param id
     * @param date
     * @param language
     * @param recipientNihii
     * @param recipientSsin
     * @param recipientFirstName
     * @param recipientLastName
     * @param mimeType
     * @param body
     * @return RequestConfig
     */
    fun generateResultExportRequestConfig(
        patientId: String,
        id: String,
        date: Long,
        language: String,
        recipientNihii: String,
        recipientSsin: String,
        recipientFirstName: String,
        recipientLastName: String,
        mimeType: String,
        body: kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
    ): RequestConfig<kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>> {
        // val localVariableBody = body
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("date", listOf(date.toString()))
                put("language", listOf(language))
                put("recipientNihii", listOf(recipientNihii))
                put("recipientSsin", listOf(recipientSsin))
                put("recipientFirstName", listOf(recipientFirstName))
                put("recipientLastName", listOf(recipientLastName))
                put("mimeType", listOf(mimeType))
            }
        val localVariableHeaders: MutableMap<String, String> =
            mutableMapOf("Content-Type" to "application/octet-stream")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = body

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/result/{patientId}/export/{id}".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ).replace("{" + "id" + "}", "${URLEncoder.encode(id.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get SMF (Software Medical File) export
     *
     * @param patientId
     * @param language
     * @param softwareMedicalFileExportDto
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun generateSmfExport(
        patientId: String,
        language: String,
        softwareMedicalFileExportDto: SoftwareMedicalFileExportDto
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = generateSmfExportRequestConfig(
            patientId = patientId,
            language = language,
            softwareMedicalFileExportDto = softwareMedicalFileExportDto
        )

        return request<SoftwareMedicalFileExportDto, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation generateSmfExport
     *
     * @param patientId
     * @param language
     * @param softwareMedicalFileExportDto
     * @return RequestConfig
     */
    fun generateSmfExportRequestConfig(
        patientId: String,
        language: String,
        softwareMedicalFileExportDto: SoftwareMedicalFileExportDto
    ): RequestConfig<SoftwareMedicalFileExportDto> {
        // val localVariableBody = softwareMedicalFileExportDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("language", listOf(language))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = softwareMedicalFileExportDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/smf/{patientId}/export".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Generate sumehr
     *
     * @param patientId
     * @param language
     * @param sumehrExportInfoDto
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun generateSumehr(
        patientId: String,
        language: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = generateSumehrRequestConfig(
            patientId = patientId,
            language = language,
            sumehrExportInfoDto = sumehrExportInfoDto
        )

        return request<SumehrExportInfoDto, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation generateSumehr
     *
     * @param patientId
     * @param language
     * @param sumehrExportInfoDto
     * @return RequestConfig
     */
    fun generateSumehrRequestConfig(
        patientId: String,
        language: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): RequestConfig<SumehrExportInfoDto> {
        // val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("language", listOf(language))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = sumehrExportInfoDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/sumehr/{patientId}/export".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Generate sumehr
     *
     * @param patientId
     * @param language
     * @param sumehrExportInfoDto
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun generateSumehrV2(
        patientId: String,
        language: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = generateSumehrV2RequestConfig(
            patientId = patientId,
            language = language,
            sumehrExportInfoDto = sumehrExportInfoDto
        )

        return request<SumehrExportInfoDto, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation generateSumehrV2
     *
     * @param patientId
     * @param language
     * @param sumehrExportInfoDto
     * @return RequestConfig
     */
    fun generateSumehrV2RequestConfig(
        patientId: String,
        language: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): RequestConfig<SumehrExportInfoDto> {
        // val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("language", listOf(language))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = sumehrExportInfoDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/sumehrv2/{patientId}/export".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get sumehr elements
     *
     * @param patientId
     * @param sumehrExportInfoDto
     * @return SumehrContentDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getSumehrContent(patientId: String, sumehrExportInfoDto: SumehrExportInfoDto): SumehrContentDto {
        val localVariableConfig =
            getSumehrContentRequestConfig(patientId = patientId, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, SumehrContentDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getSumehrContent
     *
     * @param patientId
     * @param sumehrExportInfoDto
     * @return RequestConfig
     */
    fun getSumehrContentRequestConfig(
        patientId: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): RequestConfig<SumehrExportInfoDto> {
        // val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = sumehrExportInfoDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/sumehr/{patientId}/content".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Check sumehr signature
     *
     * @param patientId
     * @param sumehrExportInfoDto
     * @return ContentDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getSumehrMd5(patientId: String, sumehrExportInfoDto: SumehrExportInfoDto): ContentDto {
        val localVariableConfig =
            getSumehrMd5RequestConfig(patientId = patientId, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, ContentDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getSumehrMd5
     *
     * @param patientId
     * @param sumehrExportInfoDto
     * @return RequestConfig
     */
    fun getSumehrMd5RequestConfig(
        patientId: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): RequestConfig<SumehrExportInfoDto> {
        // val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = sumehrExportInfoDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/sumehr/{patientId}/md5".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get sumehr elements
     *
     * @param patientId
     * @param sumehrExportInfoDto
     * @return SumehrContentDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getSumehrV2Content(
        patientId: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): SumehrContentDto {
        val localVariableConfig =
            getSumehrV2ContentRequestConfig(patientId = patientId, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, SumehrContentDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getSumehrV2Content
     *
     * @param patientId
     * @param sumehrExportInfoDto
     * @return RequestConfig
     */
    fun getSumehrV2ContentRequestConfig(
        patientId: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): RequestConfig<SumehrExportInfoDto> {
        // val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = sumehrExportInfoDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/sumehrv2/{patientId}/content".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Check sumehr signature
     *
     * @param patientId
     * @param sumehrExportInfoDto
     * @return ContentDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getSumehrV2Md5(patientId: String, sumehrExportInfoDto: SumehrExportInfoDto): ContentDto {
        val localVariableConfig =
            getSumehrV2Md5RequestConfig(patientId = patientId, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, ContentDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getSumehrV2Md5
     *
     * @param patientId
     * @param sumehrExportInfoDto
     * @return RequestConfig
     */
    fun getSumehrV2Md5RequestConfig(
        patientId: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): RequestConfig<SumehrExportInfoDto> {
        // val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = sumehrExportInfoDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/sumehrv2/{patientId}/md5".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Import MedicationScheme into patient(s) using existing document
     *
     * @param documentId
     * @param documentKey  (optional)
     * @param dryRun Dry run: do not save in database (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @param requestBody  (optional)
     * @return kotlin.collections.List<ImportResultDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun importMedicationScheme(
        documentId: String,
        documentKey: String?,
        dryRun: Boolean?,
        patientId: String?,
        language: String?,
        requestBody: Map<String, List<ImportMapping>>?
    ): List<ImportResultDto> {
        val localVariableConfig = importMedicationSchemeRequestConfig(
            documentId = documentId,
            documentKey = documentKey,
            dryRun = dryRun,
            patientId = patientId,
            language = language,
            requestBody = requestBody
        )

        return request<Map<String, List<ImportMapping>>, List<ImportResultDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation importMedicationScheme
     *
     * @param documentId
     * @param documentKey  (optional)
     * @param dryRun Dry run: do not save in database (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @param requestBody  (optional)
     * @return RequestConfig
     */
    fun importMedicationSchemeRequestConfig(
        documentId: String,
        documentKey: String?,
        dryRun: Boolean?,
        patientId: String?,
        language: String?,
        requestBody: Map<String, List<ImportMapping>>?
    ): RequestConfig<Map<String, List<ImportMapping>>> {
        // val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (documentKey != null) {
                    put("documentKey", listOf(documentKey.toString()))
                }
                if (dryRun != null) {
                    put("dryRun", listOf(dryRun.toString()))
                }
                if (patientId != null) {
                    put("patientId", listOf(patientId))
                }
                if (language != null) {
                    put("language", listOf(language))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = requestBody

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/medicationscheme/{documentId}/import".replace(
                "{" + "documentId" + "}",
                "${URLEncoder.encode(documentId.toString(), Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Import SMF into patient(s) using existing document
     *
     * @param documentId
     * @param documentKey  (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @param dryRun  (optional)
     * @param requestBody  (optional)
     * @return kotlin.collections.List<ImportResultDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun importSmf(
        documentId: String,
        documentKey: String?,
        patientId: String?,
        language: String?,
        dryRun: Boolean?,
        requestBody: Map<String, List<ImportMapping>>?
    ): List<ImportResultDto> {
        val localVariableConfig = importSmfRequestConfig(
            documentId = documentId,
            documentKey = documentKey,
            patientId = patientId,
            language = language,
            dryRun = dryRun,
            requestBody = requestBody
        )

        return request<Map<String, List<ImportMapping>>, List<ImportResultDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation importSmf
     *
     * @param documentId
     * @param documentKey  (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @param dryRun  (optional)
     * @param requestBody  (optional)
     * @return RequestConfig
     */
    fun importSmfRequestConfig(
        documentId: String,
        documentKey: String?,
        patientId: String?,
        language: String?,
        dryRun: Boolean?,
        requestBody: Map<String, List<ImportMapping>>?
    ): RequestConfig<Map<String, List<ImportMapping>>> {
        // val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (documentKey != null) {
                    put("documentKey", listOf(documentKey.toString()))
                }
                if (patientId != null) {
                    put("patientId", listOf(patientId))
                }
                if (language != null) {
                    put("language", listOf(language))
                }
                if (dryRun != null) {
                    put("dryRun", listOf(dryRun.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = requestBody

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/smf/{documentId}/import".replace(
                "{" + "documentId" + "}",
                "${URLEncoder.encode(documentId.toString(), Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Import sumehr into patient(s) using existing document
     *
     * @param documentId
     * @param documentKey  (optional)
     * @param dryRun Dry run: do not save in database (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @param requestBody  (optional)
     * @return kotlin.collections.List<ImportResultDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun importSumehr(
        documentId: String,
        documentKey: String?,
        dryRun: Boolean?,
        patientId: String?,
        language: String?,
        requestBody: Map<String, List<ImportMapping>>?
    ): List<ImportResultDto> {
        val localVariableConfig = importSumehrRequestConfig(
            documentId = documentId,
            documentKey = documentKey,
            dryRun = dryRun,
            patientId = patientId,
            language = language,
            requestBody = requestBody
        )

        return request<Map<String, List<ImportMapping>>, List<ImportResultDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation importSumehr
     *
     * @param documentId
     * @param documentKey  (optional)
     * @param dryRun Dry run: do not save in database (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @param requestBody  (optional)
     * @return RequestConfig
     */
    fun importSumehrRequestConfig(
        documentId: String,
        documentKey: String?,
        dryRun: Boolean?,
        patientId: String?,
        language: String?,
        requestBody: Map<String, List<ImportMapping>>?
    ): RequestConfig<Map<String, List<ImportMapping>>> {
        // val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (documentKey != null) {
                    put("documentKey", listOf(documentKey.toString()))
                }
                if (dryRun != null) {
                    put("dryRun", listOf(dryRun.toString()))
                }
                if (patientId != null) {
                    put("patientId", listOf(patientId))
                }
                if (language != null) {
                    put("language", listOf(language))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = requestBody

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/sumehr/{documentId}/import".replace(
                "{" + "documentId" + "}",
                "${URLEncoder.encode(documentId.toString(), Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Import sumehr into patient(s) using existing document
     *
     * @param documentId
     * @param itemId
     * @param documentKey  (optional)
     * @param dryRun Dry run: do not save in database (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @param requestBody  (optional)
     * @return kotlin.collections.List<ImportResultDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun importSumehrByItemId(
        documentId: String,
        itemId: String,
        documentKey: String?,
        dryRun: Boolean?,
        patientId: String?,
        language: String?,
        requestBody: Map<String, List<ImportMapping>>?
    ): List<ImportResultDto> {
        val localVariableConfig = importSumehrByItemIdRequestConfig(
            documentId = documentId,
            itemId = itemId,
            documentKey = documentKey,
            dryRun = dryRun,
            patientId = patientId,
            language = language,
            requestBody = requestBody
        )

        return request<Map<String, List<ImportMapping>>, List<ImportResultDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation importSumehrByItemId
     *
     * @param documentId
     * @param itemId
     * @param documentKey  (optional)
     * @param dryRun Dry run: do not save in database (optional)
     * @param patientId  (optional)
     * @param language  (optional)
     * @param requestBody  (optional)
     * @return RequestConfig
     */
    fun importSumehrByItemIdRequestConfig(
        documentId: String,
        itemId: String,
        documentKey: String?,
        dryRun: Boolean?,
        patientId: String?,
        language: String?,
        requestBody: Map<String, List<ImportMapping>>?
    ): RequestConfig<Map<String, List<ImportMapping>>> {
        // val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("itemId", listOf(itemId.toString()))
                if (documentKey != null) {
                    put("documentKey", listOf(documentKey.toString()))
                }
                if (dryRun != null) {
                    put("dryRun", listOf(dryRun.toString()))
                }
                if (patientId != null) {
                    put("patientId", listOf(patientId))
                }
                if (language != null) {
                    put("language", listOf(language))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = requestBody

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/sumehr/{documentId}/importbyitemid".replace(
                "{" + "documentId" + "}",
                "${URLEncoder.encode(documentId.toString(), Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get sumehr validity
     *
     * @param patientId
     * @param sumehrExportInfoDto
     * @return SumehrValidityDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun isSumehrV2Valid(patientId: String, sumehrExportInfoDto: SumehrExportInfoDto): SumehrValidityDto {
        val localVariableConfig =
            isSumehrV2ValidRequestConfig(patientId = patientId, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, SumehrValidityDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation isSumehrV2Valid
     *
     * @param patientId
     * @param sumehrExportInfoDto
     * @return RequestConfig
     */
    fun isSumehrV2ValidRequestConfig(
        patientId: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): RequestConfig<SumehrExportInfoDto> {
        // val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = sumehrExportInfoDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/sumehrv2/{patientId}/valid".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get sumehr validity
     *
     * @param patientId
     * @param sumehrExportInfoDto
     * @return SumehrValidityDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun isSumehrValid(patientId: String, sumehrExportInfoDto: SumehrExportInfoDto): SumehrValidityDto {
        val localVariableConfig =
            isSumehrValidRequestConfig(patientId = patientId, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, SumehrValidityDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation isSumehrValid
     *
     * @param patientId
     * @param sumehrExportInfoDto
     * @return RequestConfig
     */
    fun isSumehrValidRequestConfig(
        patientId: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): RequestConfig<SumehrExportInfoDto> {
        // val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = sumehrExportInfoDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/sumehr/{patientId}/valid".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Validate sumehr
     *
     * @param patientId
     * @param language
     * @param sumehrExportInfoDto
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun validateSumehr(
        patientId: String,
        language: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = validateSumehrRequestConfig(
            patientId = patientId,
            language = language,
            sumehrExportInfoDto = sumehrExportInfoDto
        )

        return request<SumehrExportInfoDto, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation validateSumehr
     *
     * @param patientId
     * @param language
     * @param sumehrExportInfoDto
     * @return RequestConfig
     */
    fun validateSumehrRequestConfig(
        patientId: String,
        language: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): RequestConfig<SumehrExportInfoDto> {
        // val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("language", listOf(language))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = sumehrExportInfoDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/sumehr/{patientId}/validate".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Validate sumehr
     *
     * @param patientId
     * @param language
     * @param sumehrExportInfoDto
     * @return kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun validateSumehrV2(
        patientId: String,
        language: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer> {
        val localVariableConfig = validateSumehrV2RequestConfig(
            patientId = patientId,
            language = language,
            sumehrExportInfoDto = sumehrExportInfoDto
        )

        return request<SumehrExportInfoDto, kotlinx.coroutines.flow.Flow<java.nio.ByteBuffer>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation validateSumehrV2
     *
     * @param patientId
     * @param language
     * @param sumehrExportInfoDto
     * @return RequestConfig
     */
    fun validateSumehrV2RequestConfig(
        patientId: String,
        language: String,
        sumehrExportInfoDto: SumehrExportInfoDto
    ): RequestConfig<SumehrExportInfoDto> {
        // val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("language", listOf(language))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "application/octet-stream"
        val localVariableBody = sumehrExportInfoDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/be_kmehr/sumehrv2/{patientId}/validate".replace(
                "{" + "patientId" + "}",
                "${URLEncoder.encode(patientId, Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
