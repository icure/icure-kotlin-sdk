/**
 * iCure Cloud API Documentation
 *
 * Spring shop sample application
 *
 * The version of the OpenAPI document: v0.0.1
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
package io.icure.kraken.client.apis

import io.icure.asyncjacksonhttpclient.net.web.WebClient
import io.icure.asyncjacksonhttpclient.netty.NettyWebClient
import io.icure.kraken.client.models.CheckSMFPatientResult
import io.icure.kraken.client.models.ContentDto
import io.icure.kraken.client.models.DiaryNoteExportInfoDto
import io.icure.kraken.client.models.ImportMapping
import io.icure.kraken.client.models.ImportResultDto
import io.icure.kraken.client.models.MedicationSchemeExportInfoDto
import io.icure.kraken.client.models.SoftwareMedicalFileExportDto
import io.icure.kraken.client.models.SumehrContentDto
import io.icure.kraken.client.models.SumehrExportInfoDto
import io.icure.kraken.client.models.SumehrValidityDto


import io.icure.kraken.client.infrastructure.ApiClient
import io.icure.kraken.client.infrastructure.ClientException
import io.icure.kraken.client.infrastructure.ServerException
import io.icure.kraken.client.infrastructure.MultiValueMap
import io.icure.kraken.client.infrastructure.RequestConfig
import io.icure.kraken.client.infrastructure.RequestMethod
import javax.inject.Named

@Named
@ExperimentalStdlibApi
@ExperimentalCoroutinesApi
class BekmehrApi(basePath: kotlin.String = defaultBasePath, webClient: WebClient = NettyWebClient(), authHeader: String? = null) : ApiClient(basePath, webClient, authHeader) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("io.icure.kraken.client.baseUrl", "https://kraken.icure.dev")
        }
    }

    /**
    * Check whether patients in SMF already exists in DB
    * 
    * @param documentId  
    * @param documentKey  (optional)
    * @param patientId  (optional)
    * @param language  (optional)
    * @param requestBody  (optional)
    * @return kotlin.collections.List<CheckSMFPatientResult>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun checkIfSMFPatientsExists(documentId: kotlin.String, documentKey: kotlin.String?, patientId: kotlin.String?, language: kotlin.String?, requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>?) : kotlin.collections.List<CheckSMFPatientResult>? {
        val localVariableConfig = checkIfSMFPatientsExistsRequestConfig(documentId = documentId, documentKey = documentKey, patientId = patientId, language = language, requestBody = requestBody)

        return request<kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>, kotlin.collections.List<CheckSMFPatientResult>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation checkIfSMFPatientsExists
    *
    * @param documentId  
    * @param documentKey  (optional)
    * @param patientId  (optional)
    * @param language  (optional)
    * @param requestBody  (optional)
    * @return RequestConfig
    */
    fun checkIfSMFPatientsExistsRequestConfig(documentId: kotlin.String, documentKey: kotlin.String?, patientId: kotlin.String?, language: kotlin.String?, requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>?) : RequestConfig<kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (documentKey != null) {
                    put("documentKey", listOf(documentKey.toString()))
                }
                if (patientId != null) {
                    put("patientId", listOf(patientId.toString()))
                }
                if (language != null) {
                    put("language", listOf(language.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/smf/{documentId}/checkIfSMFPatientsExists".replace("{"+"documentId"+"}", "$documentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Kmehr contactreport
    * 
    * @param patientId  
    * @param id  
    * @param date  
    * @param language  
    * @param recipientNihii  
    * @param recipientSsin  
    * @param recipientFirstName  
    * @param recipientLastName  
    * @param mimeType  
    * @param requestBody  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateContactreportExport(patientId: kotlin.String, id: kotlin.String, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, requestBody: kotlin.collections.List<kotlin.ByteArray>) : java.io.File? {
        val localVariableConfig = generateContactreportExportRequestConfig(patientId = patientId, id = id, date = date, language = language, recipientNihii = recipientNihii, recipientSsin = recipientSsin, recipientFirstName = recipientFirstName, recipientLastName = recipientLastName, mimeType = mimeType, requestBody = requestBody)

        return request<kotlin.collections.List<kotlin.ByteArray>, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation generateContactreportExport
    *
    * @param patientId  
    * @param id  
    * @param date  
    * @param language  
    * @param recipientNihii  
    * @param recipientSsin  
    * @param recipientFirstName  
    * @param recipientLastName  
    * @param mimeType  
    * @param requestBody  
    * @return RequestConfig
    */
    fun generateContactreportExportRequestConfig(patientId: kotlin.String, id: kotlin.String, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, requestBody: kotlin.collections.List<kotlin.ByteArray>) : RequestConfig<kotlin.collections.List<kotlin.ByteArray>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("date", listOf(date.toString()))
                put("language", listOf(language.toString()))
                put("recipientNihii", listOf(recipientNihii.toString()))
                put("recipientSsin", listOf(recipientSsin.toString()))
                put("recipientFirstName", listOf(recipientFirstName.toString()))
                put("recipientLastName", listOf(recipientLastName.toString()))
                put("mimeType", listOf(mimeType.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/contactreport/{patientId}/export/{id}".replace("{"+"patientId"+"}", "$patientId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Generate diarynote
    * 
    * @param patientId  
    * @param language  
    * @param diaryNoteExportInfoDto  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateDiaryNote(patientId: kotlin.String, language: kotlin.String, diaryNoteExportInfoDto: DiaryNoteExportInfoDto) : java.io.File? {
        val localVariableConfig = generateDiaryNoteRequestConfig(patientId = patientId, language = language, diaryNoteExportInfoDto = diaryNoteExportInfoDto)

        return request<DiaryNoteExportInfoDto, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation generateDiaryNote
    *
    * @param patientId  
    * @param language  
    * @param diaryNoteExportInfoDto  
    * @return RequestConfig
    */
    fun generateDiaryNoteRequestConfig(patientId: kotlin.String, language: kotlin.String, diaryNoteExportInfoDto: DiaryNoteExportInfoDto) : RequestConfig<DiaryNoteExportInfoDto> {
        val localVariableBody = diaryNoteExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("language", listOf(language.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/diarynote/{patientId}/export".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Kmehr labresult
    * 
    * @param patientId  
    * @param id  
    * @param date  
    * @param language  
    * @param recipientNihii  
    * @param recipientSsin  
    * @param recipientFirstName  
    * @param recipientLastName  
    * @param mimeType  
    * @param requestBody  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateLabresultExport(patientId: kotlin.String, id: kotlin.String, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, requestBody: kotlin.collections.List<kotlin.ByteArray>) : java.io.File? {
        val localVariableConfig = generateLabresultExportRequestConfig(patientId = patientId, id = id, date = date, language = language, recipientNihii = recipientNihii, recipientSsin = recipientSsin, recipientFirstName = recipientFirstName, recipientLastName = recipientLastName, mimeType = mimeType, requestBody = requestBody)

        return request<kotlin.collections.List<kotlin.ByteArray>, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation generateLabresultExport
    *
    * @param patientId  
    * @param id  
    * @param date  
    * @param language  
    * @param recipientNihii  
    * @param recipientSsin  
    * @param recipientFirstName  
    * @param recipientLastName  
    * @param mimeType  
    * @param requestBody  
    * @return RequestConfig
    */
    fun generateLabresultExportRequestConfig(patientId: kotlin.String, id: kotlin.String, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, requestBody: kotlin.collections.List<kotlin.ByteArray>) : RequestConfig<kotlin.collections.List<kotlin.ByteArray>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("date", listOf(date.toString()))
                put("language", listOf(language.toString()))
                put("recipientNihii", listOf(recipientNihii.toString()))
                put("recipientSsin", listOf(recipientSsin.toString()))
                put("recipientFirstName", listOf(recipientFirstName.toString()))
                put("recipientLastName", listOf(recipientLastName.toString()))
                put("mimeType", listOf(mimeType.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/labresult/{patientId}/export/{id}".replace("{"+"patientId"+"}", "$patientId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Medicationscheme export
    * 
    * @param patientId  
    * @param language  
    * @param recipientSafe  
    * @param version  
    * @param medicationSchemeExportInfoDto  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateMedicationSchemeExport(patientId: kotlin.String, language: kotlin.String, recipientSafe: kotlin.String, version: kotlin.Int, medicationSchemeExportInfoDto: MedicationSchemeExportInfoDto) : java.io.File? {
        val localVariableConfig = generateMedicationSchemeExportRequestConfig(patientId = patientId, language = language, recipientSafe = recipientSafe, version = version, medicationSchemeExportInfoDto = medicationSchemeExportInfoDto)

        return request<MedicationSchemeExportInfoDto, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation generateMedicationSchemeExport
    *
    * @param patientId  
    * @param language  
    * @param recipientSafe  
    * @param version  
    * @param medicationSchemeExportInfoDto  
    * @return RequestConfig
    */
    fun generateMedicationSchemeExportRequestConfig(patientId: kotlin.String, language: kotlin.String, recipientSafe: kotlin.String, version: kotlin.Int, medicationSchemeExportInfoDto: MedicationSchemeExportInfoDto) : RequestConfig<MedicationSchemeExportInfoDto> {
        val localVariableBody = medicationSchemeExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("language", listOf(language.toString()))
                put("recipientSafe", listOf(recipientSafe.toString()))
                put("version", listOf(version.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/medicationscheme/{patientId}/export".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Kmehr note
    * 
    * @param patientId  
    * @param id  
    * @param date  
    * @param language  
    * @param recipientNihii  
    * @param recipientSsin  
    * @param recipientFirstName  
    * @param recipientLastName  
    * @param mimeType  
    * @param requestBody  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateNoteExport(patientId: kotlin.String, id: kotlin.String, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, requestBody: kotlin.collections.List<kotlin.ByteArray>) : java.io.File? {
        val localVariableConfig = generateNoteExportRequestConfig(patientId = patientId, id = id, date = date, language = language, recipientNihii = recipientNihii, recipientSsin = recipientSsin, recipientFirstName = recipientFirstName, recipientLastName = recipientLastName, mimeType = mimeType, requestBody = requestBody)

        return request<kotlin.collections.List<kotlin.ByteArray>, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation generateNoteExport
    *
    * @param patientId  
    * @param id  
    * @param date  
    * @param language  
    * @param recipientNihii  
    * @param recipientSsin  
    * @param recipientFirstName  
    * @param recipientLastName  
    * @param mimeType  
    * @param requestBody  
    * @return RequestConfig
    */
    fun generateNoteExportRequestConfig(patientId: kotlin.String, id: kotlin.String, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, requestBody: kotlin.collections.List<kotlin.ByteArray>) : RequestConfig<kotlin.collections.List<kotlin.ByteArray>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("date", listOf(date.toString()))
                put("language", listOf(language.toString()))
                put("recipientNihii", listOf(recipientNihii.toString()))
                put("recipientSsin", listOf(recipientSsin.toString()))
                put("recipientFirstName", listOf(recipientFirstName.toString()))
                put("recipientLastName", listOf(recipientLastName.toString()))
                put("mimeType", listOf(mimeType.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/note/{patientId}/export/{id}".replace("{"+"patientId"+"}", "$patientId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get KMEHR Patient Info export
    * 
    * @param patientId  
    * @param language  (optional)
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generatePatientInfoExport(patientId: kotlin.String, language: kotlin.String?) : java.io.File? {
        val localVariableConfig = generatePatientInfoExportRequestConfig(patientId = patientId, language = language)

        return request<Unit, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation generatePatientInfoExport
    *
    * @param patientId  
    * @param language  (optional)
    * @return RequestConfig
    */
    fun generatePatientInfoExportRequestConfig(patientId: kotlin.String, language: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (language != null) {
                    put("language", listOf(language.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/patientinfo/{patientId}/export".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Kmehr prescription
    * 
    * @param patientId  
    * @param id  
    * @param date  
    * @param language  
    * @param recipientNihii  
    * @param recipientSsin  
    * @param recipientFirstName  
    * @param recipientLastName  
    * @param mimeType  
    * @param requestBody  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generatePrescriptionExport(patientId: kotlin.String, id: kotlin.String, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, requestBody: kotlin.collections.List<kotlin.ByteArray>) : java.io.File? {
        val localVariableConfig = generatePrescriptionExportRequestConfig(patientId = patientId, id = id, date = date, language = language, recipientNihii = recipientNihii, recipientSsin = recipientSsin, recipientFirstName = recipientFirstName, recipientLastName = recipientLastName, mimeType = mimeType, requestBody = requestBody)

        return request<kotlin.collections.List<kotlin.ByteArray>, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation generatePrescriptionExport
    *
    * @param patientId  
    * @param id  
    * @param date  
    * @param language  
    * @param recipientNihii  
    * @param recipientSsin  
    * @param recipientFirstName  
    * @param recipientLastName  
    * @param mimeType  
    * @param requestBody  
    * @return RequestConfig
    */
    fun generatePrescriptionExportRequestConfig(patientId: kotlin.String, id: kotlin.String, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, requestBody: kotlin.collections.List<kotlin.ByteArray>) : RequestConfig<kotlin.collections.List<kotlin.ByteArray>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("date", listOf(date.toString()))
                put("language", listOf(language.toString()))
                put("recipientNihii", listOf(recipientNihii.toString()))
                put("recipientSsin", listOf(recipientSsin.toString()))
                put("recipientFirstName", listOf(recipientFirstName.toString()))
                put("recipientLastName", listOf(recipientLastName.toString()))
                put("mimeType", listOf(mimeType.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/prescription/{patientId}/export/{id}".replace("{"+"patientId"+"}", "$patientId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Kmehr report
    * 
    * @param patientId  
    * @param id  
    * @param date  
    * @param language  
    * @param recipientNihii  
    * @param recipientSsin  
    * @param recipientFirstName  
    * @param recipientLastName  
    * @param mimeType  
    * @param requestBody  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateReportExport(patientId: kotlin.String, id: kotlin.String, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, requestBody: kotlin.collections.List<kotlin.ByteArray>) : java.io.File? {
        val localVariableConfig = generateReportExportRequestConfig(patientId = patientId, id = id, date = date, language = language, recipientNihii = recipientNihii, recipientSsin = recipientSsin, recipientFirstName = recipientFirstName, recipientLastName = recipientLastName, mimeType = mimeType, requestBody = requestBody)

        return request<kotlin.collections.List<kotlin.ByteArray>, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation generateReportExport
    *
    * @param patientId  
    * @param id  
    * @param date  
    * @param language  
    * @param recipientNihii  
    * @param recipientSsin  
    * @param recipientFirstName  
    * @param recipientLastName  
    * @param mimeType  
    * @param requestBody  
    * @return RequestConfig
    */
    fun generateReportExportRequestConfig(patientId: kotlin.String, id: kotlin.String, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, requestBody: kotlin.collections.List<kotlin.ByteArray>) : RequestConfig<kotlin.collections.List<kotlin.ByteArray>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("date", listOf(date.toString()))
                put("language", listOf(language.toString()))
                put("recipientNihii", listOf(recipientNihii.toString()))
                put("recipientSsin", listOf(recipientSsin.toString()))
                put("recipientFirstName", listOf(recipientFirstName.toString()))
                put("recipientLastName", listOf(recipientLastName.toString()))
                put("mimeType", listOf(mimeType.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/report/{patientId}/export/{id}".replace("{"+"patientId"+"}", "$patientId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Kmehr request
    * 
    * @param patientId  
    * @param id  
    * @param date  
    * @param language  
    * @param recipientNihii  
    * @param recipientSsin  
    * @param recipientFirstName  
    * @param recipientLastName  
    * @param mimeType  
    * @param requestBody  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateRequestExport(patientId: kotlin.String, id: kotlin.String, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, requestBody: kotlin.collections.List<kotlin.ByteArray>) : java.io.File? {
        val localVariableConfig = generateRequestExportRequestConfig(patientId = patientId, id = id, date = date, language = language, recipientNihii = recipientNihii, recipientSsin = recipientSsin, recipientFirstName = recipientFirstName, recipientLastName = recipientLastName, mimeType = mimeType, requestBody = requestBody)

        return request<kotlin.collections.List<kotlin.ByteArray>, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation generateRequestExport
    *
    * @param patientId  
    * @param id  
    * @param date  
    * @param language  
    * @param recipientNihii  
    * @param recipientSsin  
    * @param recipientFirstName  
    * @param recipientLastName  
    * @param mimeType  
    * @param requestBody  
    * @return RequestConfig
    */
    fun generateRequestExportRequestConfig(patientId: kotlin.String, id: kotlin.String, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, requestBody: kotlin.collections.List<kotlin.ByteArray>) : RequestConfig<kotlin.collections.List<kotlin.ByteArray>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("date", listOf(date.toString()))
                put("language", listOf(language.toString()))
                put("recipientNihii", listOf(recipientNihii.toString()))
                put("recipientSsin", listOf(recipientSsin.toString()))
                put("recipientFirstName", listOf(recipientFirstName.toString()))
                put("recipientLastName", listOf(recipientLastName.toString()))
                put("mimeType", listOf(mimeType.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/request/{patientId}/export/{id}".replace("{"+"patientId"+"}", "$patientId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Kmehr result
    * 
    * @param patientId  
    * @param id  
    * @param date  
    * @param language  
    * @param recipientNihii  
    * @param recipientSsin  
    * @param recipientFirstName  
    * @param recipientLastName  
    * @param mimeType  
    * @param requestBody  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateResultExport(patientId: kotlin.String, id: kotlin.String, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, requestBody: kotlin.collections.List<kotlin.ByteArray>) : java.io.File? {
        val localVariableConfig = generateResultExportRequestConfig(patientId = patientId, id = id, date = date, language = language, recipientNihii = recipientNihii, recipientSsin = recipientSsin, recipientFirstName = recipientFirstName, recipientLastName = recipientLastName, mimeType = mimeType, requestBody = requestBody)

        return request<kotlin.collections.List<kotlin.ByteArray>, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation generateResultExport
    *
    * @param patientId  
    * @param id  
    * @param date  
    * @param language  
    * @param recipientNihii  
    * @param recipientSsin  
    * @param recipientFirstName  
    * @param recipientLastName  
    * @param mimeType  
    * @param requestBody  
    * @return RequestConfig
    */
    fun generateResultExportRequestConfig(patientId: kotlin.String, id: kotlin.String, date: kotlin.Long, language: kotlin.String, recipientNihii: kotlin.String, recipientSsin: kotlin.String, recipientFirstName: kotlin.String, recipientLastName: kotlin.String, mimeType: kotlin.String, requestBody: kotlin.collections.List<kotlin.ByteArray>) : RequestConfig<kotlin.collections.List<kotlin.ByteArray>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("date", listOf(date.toString()))
                put("language", listOf(language.toString()))
                put("recipientNihii", listOf(recipientNihii.toString()))
                put("recipientSsin", listOf(recipientSsin.toString()))
                put("recipientFirstName", listOf(recipientFirstName.toString()))
                put("recipientLastName", listOf(recipientLastName.toString()))
                put("mimeType", listOf(mimeType.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/result/{patientId}/export/{id}".replace("{"+"patientId"+"}", "$patientId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get SMF (Software Medical File) export
    * 
    * @param patientId  
    * @param language  
    * @param softwareMedicalFileExportDto  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateSmfExport(patientId: kotlin.String, language: kotlin.String, softwareMedicalFileExportDto: SoftwareMedicalFileExportDto) : java.io.File? {
        val localVariableConfig = generateSmfExportRequestConfig(patientId = patientId, language = language, softwareMedicalFileExportDto = softwareMedicalFileExportDto)

        return request<SoftwareMedicalFileExportDto, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation generateSmfExport
    *
    * @param patientId  
    * @param language  
    * @param softwareMedicalFileExportDto  
    * @return RequestConfig
    */
    fun generateSmfExportRequestConfig(patientId: kotlin.String, language: kotlin.String, softwareMedicalFileExportDto: SoftwareMedicalFileExportDto) : RequestConfig<SoftwareMedicalFileExportDto> {
        val localVariableBody = softwareMedicalFileExportDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("language", listOf(language.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/smf/{patientId}/export".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Generate sumehr
    * 
    * @param patientId  
    * @param language  
    * @param sumehrExportInfoDto  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateSumehr(patientId: kotlin.String, language: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : java.io.File? {
        val localVariableConfig = generateSumehrRequestConfig(patientId = patientId, language = language, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation generateSumehr
    *
    * @param patientId  
    * @param language  
    * @param sumehrExportInfoDto  
    * @return RequestConfig
    */
    fun generateSumehrRequestConfig(patientId: kotlin.String, language: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : RequestConfig<SumehrExportInfoDto> {
        val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("language", listOf(language.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/sumehr/{patientId}/export".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Generate sumehr
    * 
    * @param patientId  
    * @param language  
    * @param sumehrExportInfoDto  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun generateSumehrV2(patientId: kotlin.String, language: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : java.io.File? {
        val localVariableConfig = generateSumehrV2RequestConfig(patientId = patientId, language = language, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation generateSumehrV2
    *
    * @param patientId  
    * @param language  
    * @param sumehrExportInfoDto  
    * @return RequestConfig
    */
    fun generateSumehrV2RequestConfig(patientId: kotlin.String, language: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : RequestConfig<SumehrExportInfoDto> {
        val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("language", listOf(language.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/sumehrv2/{patientId}/export".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get sumehr elements
    * 
    * @param patientId  
    * @param sumehrExportInfoDto  
    * @return SumehrContentDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSumehrContent(patientId: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : SumehrContentDto? {
        val localVariableConfig = getSumehrContentRequestConfig(patientId = patientId, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, SumehrContentDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getSumehrContent
    *
    * @param patientId  
    * @param sumehrExportInfoDto  
    * @return RequestConfig
    */
    fun getSumehrContentRequestConfig(patientId: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : RequestConfig<SumehrExportInfoDto> {
        val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/sumehr/{patientId}/content".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Check sumehr signature
    * 
    * @param patientId  
    * @param sumehrExportInfoDto  
    * @return ContentDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSumehrMd5(patientId: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : ContentDto? {
        val localVariableConfig = getSumehrMd5RequestConfig(patientId = patientId, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, ContentDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getSumehrMd5
    *
    * @param patientId  
    * @param sumehrExportInfoDto  
    * @return RequestConfig
    */
    fun getSumehrMd5RequestConfig(patientId: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : RequestConfig<SumehrExportInfoDto> {
        val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/sumehr/{patientId}/md5".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get sumehr elements
    * 
    * @param patientId  
    * @param sumehrExportInfoDto  
    * @return SumehrContentDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSumehrV2Content(patientId: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : SumehrContentDto? {
        val localVariableConfig = getSumehrV2ContentRequestConfig(patientId = patientId, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, SumehrContentDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getSumehrV2Content
    *
    * @param patientId  
    * @param sumehrExportInfoDto  
    * @return RequestConfig
    */
    fun getSumehrV2ContentRequestConfig(patientId: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : RequestConfig<SumehrExportInfoDto> {
        val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/sumehrv2/{patientId}/content".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Check sumehr signature
    * 
    * @param patientId  
    * @param sumehrExportInfoDto  
    * @return ContentDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSumehrV2Md5(patientId: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : ContentDto? {
        val localVariableConfig = getSumehrV2Md5RequestConfig(patientId = patientId, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, ContentDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getSumehrV2Md5
    *
    * @param patientId  
    * @param sumehrExportInfoDto  
    * @return RequestConfig
    */
    fun getSumehrV2Md5RequestConfig(patientId: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : RequestConfig<SumehrExportInfoDto> {
        val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/sumehrv2/{patientId}/md5".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Import MedicationScheme into patient(s) using existing document
    * 
    * @param documentId  
    * @param documentKey  (optional)
    * @param dryRun Dry run: do not save in database (optional)
    * @param patientId  (optional)
    * @param language  (optional)
    * @param requestBody  (optional)
    * @return kotlin.collections.List<ImportResultDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun importMedicationScheme(documentId: kotlin.String, documentKey: kotlin.String?, dryRun: kotlin.Boolean?, patientId: kotlin.String?, language: kotlin.String?, requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>?) : kotlin.collections.List<ImportResultDto>? {
        val localVariableConfig = importMedicationSchemeRequestConfig(documentId = documentId, documentKey = documentKey, dryRun = dryRun, patientId = patientId, language = language, requestBody = requestBody)

        return request<kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>, kotlin.collections.List<ImportResultDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation importMedicationScheme
    *
    * @param documentId  
    * @param documentKey  (optional)
    * @param dryRun Dry run: do not save in database (optional)
    * @param patientId  (optional)
    * @param language  (optional)
    * @param requestBody  (optional)
    * @return RequestConfig
    */
    fun importMedicationSchemeRequestConfig(documentId: kotlin.String, documentKey: kotlin.String?, dryRun: kotlin.Boolean?, patientId: kotlin.String?, language: kotlin.String?, requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>?) : RequestConfig<kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (documentKey != null) {
                    put("documentKey", listOf(documentKey.toString()))
                }
                if (dryRun != null) {
                    put("dryRun", listOf(dryRun.toString()))
                }
                if (patientId != null) {
                    put("patientId", listOf(patientId.toString()))
                }
                if (language != null) {
                    put("language", listOf(language.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/medicationscheme/{documentId}/import".replace("{"+"documentId"+"}", "$documentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Import SMF into patient(s) using existing document
    * 
    * @param documentId  
    * @param documentKey  (optional)
    * @param patientId  (optional)
    * @param language  (optional)
    * @param dryRun  (optional)
    * @param requestBody  (optional)
    * @return kotlin.collections.List<ImportResultDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun importSmf(documentId: kotlin.String, documentKey: kotlin.String?, patientId: kotlin.String?, language: kotlin.String?, dryRun: kotlin.Boolean?, requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>?) : kotlin.collections.List<ImportResultDto>? {
        val localVariableConfig = importSmfRequestConfig(documentId = documentId, documentKey = documentKey, patientId = patientId, language = language, dryRun = dryRun, requestBody = requestBody)

        return request<kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>, kotlin.collections.List<ImportResultDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation importSmf
    *
    * @param documentId  
    * @param documentKey  (optional)
    * @param patientId  (optional)
    * @param language  (optional)
    * @param dryRun  (optional)
    * @param requestBody  (optional)
    * @return RequestConfig
    */
    fun importSmfRequestConfig(documentId: kotlin.String, documentKey: kotlin.String?, patientId: kotlin.String?, language: kotlin.String?, dryRun: kotlin.Boolean?, requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>?) : RequestConfig<kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (documentKey != null) {
                    put("documentKey", listOf(documentKey.toString()))
                }
                if (patientId != null) {
                    put("patientId", listOf(patientId.toString()))
                }
                if (language != null) {
                    put("language", listOf(language.toString()))
                }
                if (dryRun != null) {
                    put("dryRun", listOf(dryRun.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/smf/{documentId}/import".replace("{"+"documentId"+"}", "$documentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Import sumehr into patient(s) using existing document
    * 
    * @param documentId  
    * @param documentKey  (optional)
    * @param dryRun Dry run: do not save in database (optional)
    * @param patientId  (optional)
    * @param language  (optional)
    * @param requestBody  (optional)
    * @return kotlin.collections.List<ImportResultDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun importSumehr(documentId: kotlin.String, documentKey: kotlin.String?, dryRun: kotlin.Boolean?, patientId: kotlin.String?, language: kotlin.String?, requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>?) : kotlin.collections.List<ImportResultDto>? {
        val localVariableConfig = importSumehrRequestConfig(documentId = documentId, documentKey = documentKey, dryRun = dryRun, patientId = patientId, language = language, requestBody = requestBody)

        return request<kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>, kotlin.collections.List<ImportResultDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation importSumehr
    *
    * @param documentId  
    * @param documentKey  (optional)
    * @param dryRun Dry run: do not save in database (optional)
    * @param patientId  (optional)
    * @param language  (optional)
    * @param requestBody  (optional)
    * @return RequestConfig
    */
    fun importSumehrRequestConfig(documentId: kotlin.String, documentKey: kotlin.String?, dryRun: kotlin.Boolean?, patientId: kotlin.String?, language: kotlin.String?, requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>?) : RequestConfig<kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (documentKey != null) {
                    put("documentKey", listOf(documentKey.toString()))
                }
                if (dryRun != null) {
                    put("dryRun", listOf(dryRun.toString()))
                }
                if (patientId != null) {
                    put("patientId", listOf(patientId.toString()))
                }
                if (language != null) {
                    put("language", listOf(language.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/sumehr/{documentId}/import".replace("{"+"documentId"+"}", "$documentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Import sumehr into patient(s) using existing document
    * 
    * @param documentId  
    * @param itemId  
    * @param documentKey  (optional)
    * @param dryRun Dry run: do not save in database (optional)
    * @param patientId  (optional)
    * @param language  (optional)
    * @param requestBody  (optional)
    * @return kotlin.collections.List<ImportResultDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun importSumehrByItemId(documentId: kotlin.String, itemId: kotlin.String, documentKey: kotlin.String?, dryRun: kotlin.Boolean?, patientId: kotlin.String?, language: kotlin.String?, requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>?) : kotlin.collections.List<ImportResultDto>? {
        val localVariableConfig = importSumehrByItemIdRequestConfig(documentId = documentId, itemId = itemId, documentKey = documentKey, dryRun = dryRun, patientId = patientId, language = language, requestBody = requestBody)

        return request<kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>, kotlin.collections.List<ImportResultDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation importSumehrByItemId
    *
    * @param documentId  
    * @param itemId  
    * @param documentKey  (optional)
    * @param dryRun Dry run: do not save in database (optional)
    * @param patientId  (optional)
    * @param language  (optional)
    * @param requestBody  (optional)
    * @return RequestConfig
    */
    fun importSumehrByItemIdRequestConfig(documentId: kotlin.String, itemId: kotlin.String, documentKey: kotlin.String?, dryRun: kotlin.Boolean?, patientId: kotlin.String?, language: kotlin.String?, requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>?) : RequestConfig<kotlin.collections.Map<kotlin.String, kotlin.collections.List<ImportMapping>>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("itemId", listOf(itemId.toString()))
                if (documentKey != null) {
                    put("documentKey", listOf(documentKey.toString()))
                }
                if (dryRun != null) {
                    put("dryRun", listOf(dryRun.toString()))
                }
                if (patientId != null) {
                    put("patientId", listOf(patientId.toString()))
                }
                if (language != null) {
                    put("language", listOf(language.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/sumehr/{documentId}/importbyitemid".replace("{"+"documentId"+"}", "$documentId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get sumehr validity
    * 
    * @param patientId  
    * @param sumehrExportInfoDto  
    * @return SumehrValidityDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun isSumehrV2Valid(patientId: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : SumehrValidityDto? {
        val localVariableConfig = isSumehrV2ValidRequestConfig(patientId = patientId, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, SumehrValidityDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation isSumehrV2Valid
    *
    * @param patientId  
    * @param sumehrExportInfoDto  
    * @return RequestConfig
    */
    fun isSumehrV2ValidRequestConfig(patientId: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : RequestConfig<SumehrExportInfoDto> {
        val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/sumehrv2/{patientId}/valid".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get sumehr validity
    * 
    * @param patientId  
    * @param sumehrExportInfoDto  
    * @return SumehrValidityDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun isSumehrValid(patientId: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : SumehrValidityDto? {
        val localVariableConfig = isSumehrValidRequestConfig(patientId = patientId, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, SumehrValidityDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation isSumehrValid
    *
    * @param patientId  
    * @param sumehrExportInfoDto  
    * @return RequestConfig
    */
    fun isSumehrValidRequestConfig(patientId: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : RequestConfig<SumehrExportInfoDto> {
        val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/sumehr/{patientId}/valid".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Validate sumehr
    * 
    * @param patientId  
    * @param language  
    * @param sumehrExportInfoDto  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun validateSumehr(patientId: kotlin.String, language: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : java.io.File? {
        val localVariableConfig = validateSumehrRequestConfig(patientId = patientId, language = language, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation validateSumehr
    *
    * @param patientId  
    * @param language  
    * @param sumehrExportInfoDto  
    * @return RequestConfig
    */
    fun validateSumehrRequestConfig(patientId: kotlin.String, language: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : RequestConfig<SumehrExportInfoDto> {
        val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("language", listOf(language.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/sumehr/{patientId}/validate".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Validate sumehr
    * 
    * @param patientId  
    * @param language  
    * @param sumehrExportInfoDto  
    * @return java.io.File
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun validateSumehrV2(patientId: kotlin.String, language: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : java.io.File? {
        val localVariableConfig = validateSumehrV2RequestConfig(patientId = patientId, language = language, sumehrExportInfoDto = sumehrExportInfoDto)

        return request<SumehrExportInfoDto, java.io.File>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation validateSumehrV2
    *
    * @param patientId  
    * @param language  
    * @param sumehrExportInfoDto  
    * @return RequestConfig
    */
    fun validateSumehrV2RequestConfig(patientId: kotlin.String, language: kotlin.String, sumehrExportInfoDto: SumehrExportInfoDto) : RequestConfig<SumehrExportInfoDto> {
        val localVariableBody = sumehrExportInfoDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("language", listOf(language.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/be_kmehr/sumehrv2/{patientId}/validate".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
