/**
 * iCure Data Stack API Documentation
 *
 * The iCure Data Stack Application API is the native interface to iCure.
 *
 * The version of the OpenAPI document: v2
 *
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
package io.icure.kraken.client.apis

import io.icure.asyncjacksonhttpclient.net.web.WebClient
import io.icure.asyncjacksonhttpclient.netty.NettyWebClient
import io.icure.kraken.client.infrastructure.*
import io.icure.kraken.client.models.DocIdentifier
import org.taktik.icure.services.external.rest.v2.dto.ListOfIdsDto
import io.icure.kraken.client.security.AuthProvider
import io.icure.kraken.client.security.NoAuthProvider
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.taktik.icure.services.external.rest.v2.dto.CalendarItemDto
import org.taktik.icure.services.external.rest.v2.dto.IcureStubDto
import java.net.URLEncoder
import java.util.*
import javax.inject.Named

@Named
@ExperimentalStdlibApi
@ExperimentalCoroutinesApi
class CalendarItemApi(
    basePath: String = defaultBasePath,
    webClient: WebClient = NettyWebClient(),
    authProvider: AuthProvider = NoAuthProvider()
) : ApiClient(basePath, webClient, authProvider) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("io.icure.kraken.client.baseUrl", "https://kraken.icure.dev")
        }
    }

    /**
     * Creates a calendarItem
     *
     * @param calendarItemDto
     * @return CalendarItemDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createCalendarItem(calendarItemDto: CalendarItemDto): CalendarItemDto {
        val localVariableConfig = createCalendarItemRequestConfig(calendarItemDto = calendarItemDto)

        return request<CalendarItemDto, CalendarItemDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation createCalendarItem
     *
     * @param calendarItemDto
     * @return RequestConfig
     */
    fun createCalendarItemRequestConfig(calendarItemDto: CalendarItemDto): RequestConfig<CalendarItemDto> {
        // val localVariableBody = calendarItemDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = calendarItemDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/calendarItem",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Deletes an calendarItem
     *
     * @param calendarItemIds
     * @return kotlin.collections.List<DocIdentifier>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    suspend fun deleteCalendarItem(calendarItemIds: String): List<DocIdentifier> {
        @Suppress("DEPRECATION")
        val localVariableConfig = deleteCalendarItemRequestConfig(calendarItemIds = calendarItemIds)

        return request<Unit, List<DocIdentifier>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation deleteCalendarItem
     *
     * @param calendarItemIds
     * @return RequestConfig
     */
    @Deprecated(message = "This operation is deprecated.")
    fun deleteCalendarItemRequestConfig(calendarItemIds: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/calendarItem/{calendarItemIds}".replace(
                "{" + "calendarItemIds" + "}",
                URLEncoder.encode(calendarItemIds, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Deletes calendarItems
     *
     * @param listOfIdsDto
     * @return kotlin.collections.List<DocIdentifier>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteCalendarItems(listOfIdsDto: ListOfIdsDto): List<DocIdentifier> {
        val localVariableConfig = deleteCalendarItemsRequestConfig(listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, List<DocIdentifier>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation deleteCalendarItems
     *
     * @param listOfIdsDto
     * @return RequestConfig
     */
    fun deleteCalendarItemsRequestConfig(listOfIdsDto: ListOfIdsDto): RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/calendarItem/delete/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Find CalendarItems by hcparty and patient
     *
     * @param hcPartyId
     * @param secretFKeys
     * @return kotlin.collections.List<CalendarItemDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findCalendarItemsByHCPartyPatientForeignKeys(
        hcPartyId: String,
        secretFKeys: String
    ): List<CalendarItemDto> {
        val localVariableConfig =
            findCalendarItemsByHCPartyPatientForeignKeysRequestConfig(hcPartyId = hcPartyId, secretFKeys = secretFKeys)

        return request<Unit, List<CalendarItemDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation findCalendarItemsByHCPartyPatientForeignKeys
     *
     * @param hcPartyId
     * @param secretFKeys
     * @return RequestConfig
     */
    fun findCalendarItemsByHCPartyPatientForeignKeysRequestConfig(
        hcPartyId: String,
        secretFKeys: String
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId))
                put("secretFKeys", listOf(secretFKeys))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/calendarItem/byHcPartySecretForeignKeys",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Find CalendarItems by recurrenceId
     *
     * @param recurrenceId
     * @return kotlin.collections.List<CalendarItemDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findCalendarItemsByRecurrenceId(recurrenceId: String): List<CalendarItemDto> {
        val localVariableConfig = findCalendarItemsByRecurrenceIdRequestConfig(recurrenceId = recurrenceId)

        return request<Unit, List<CalendarItemDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation findCalendarItemsByRecurrenceId
     *
     * @param recurrenceId
     * @return RequestConfig
     */
    fun findCalendarItemsByRecurrenceIdRequestConfig(recurrenceId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("recurrenceId", listOf(recurrenceId))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/calendarItem/byRecurrenceId",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets an calendarItem
     *
     * @param calendarItemId
     * @return CalendarItemDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCalendarItem(calendarItemId: String): CalendarItemDto {
        val localVariableConfig = getCalendarItemRequestConfig(calendarItemId = calendarItemId)

        return request<Unit, CalendarItemDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getCalendarItem
     *
     * @param calendarItemId
     * @return RequestConfig
     */
    fun getCalendarItemRequestConfig(calendarItemId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/calendarItem/{calendarItemId}".replace(
                "{" + "calendarItemId" + "}",
                URLEncoder.encode(calendarItemId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets all calendarItems
     *
     * @return kotlin.collections.List<CalendarItemDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCalendarItems(): List<CalendarItemDto> {
        val localVariableConfig = getCalendarItemsRequestConfig()

        return request<Unit, List<CalendarItemDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getCalendarItems
     *
     * @return RequestConfig
     */
    fun getCalendarItemsRequestConfig(): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/calendarItem",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get CalendarItems by Period and HcPartyId
     *
     * @param startDate
     * @param endDate
     * @param hcPartyId
     * @return kotlin.collections.List<CalendarItemDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCalendarItemsByPeriodAndHcPartyId(
        startDate: Long,
        endDate: Long,
        hcPartyId: String
    ): List<CalendarItemDto> {
        val localVariableConfig = getCalendarItemsByPeriodAndHcPartyIdRequestConfig(
            startDate = startDate,
            endDate = endDate,
            hcPartyId = hcPartyId
        )

        return request<Unit, List<CalendarItemDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getCalendarItemsByPeriodAndHcPartyId
     *
     * @param startDate
     * @param endDate
     * @param hcPartyId
     * @return RequestConfig
     */
    fun getCalendarItemsByPeriodAndHcPartyIdRequestConfig(
        startDate: Long,
        endDate: Long,
        hcPartyId: String
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("startDate", listOf(startDate.toString()))
                put("endDate", listOf(endDate.toString()))
                put("hcPartyId", listOf(hcPartyId))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/calendarItem/byPeriodAndHcPartyId",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get calendarItems by ids
     *
     * @param listOfIdsDto  (optional)
     * @return kotlin.collections.List<CalendarItemDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCalendarItemsWithIds(listOfIdsDto: ListOfIdsDto?): List<CalendarItemDto> {
        val localVariableConfig = getCalendarItemsWithIdsRequestConfig(listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, List<CalendarItemDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getCalendarItemsWithIds
     *
     * @param listOfIdsDto  (optional)
     * @return RequestConfig
     */
    fun getCalendarItemsWithIdsRequestConfig(listOfIdsDto: ListOfIdsDto?): RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/calendarItem/byIds",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get CalendarItems by Period and AgendaId
     *
     * @param startDate
     * @param endDate
     * @param agendaId
     * @return kotlin.collections.List<CalendarItemDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCalendarsByPeriodAndAgendaId(
        startDate: Long,
        endDate: Long,
        agendaId: String
    ): List<CalendarItemDto> {
        val localVariableConfig =
            getCalendarsByPeriodAndAgendaIdRequestConfig(startDate = startDate, endDate = endDate, agendaId = agendaId)

        return request<Unit, List<CalendarItemDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getCalendarsByPeriodAndAgendaId
     *
     * @param startDate
     * @param endDate
     * @param agendaId
     * @return RequestConfig
     */
    fun getCalendarsByPeriodAndAgendaIdRequestConfig(
        startDate: Long,
        endDate: Long,
        agendaId: String
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("startDate", listOf(startDate.toString()))
                put("endDate", listOf(endDate.toString()))
                put("agendaId", listOf(agendaId))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/calendarItem/byPeriodAndAgendaId",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Modifies an calendarItem
     *
     * @param calendarItemDto
     * @return CalendarItemDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyCalendarItem(calendarItemDto: CalendarItemDto): CalendarItemDto {
        val localVariableConfig = modifyCalendarItemRequestConfig(calendarItemDto = calendarItemDto)

        return request<CalendarItemDto, CalendarItemDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation modifyCalendarItem
     *
     * @param calendarItemDto
     * @return RequestConfig
     */
    fun modifyCalendarItemRequestConfig(calendarItemDto: CalendarItemDto): RequestConfig<CalendarItemDto> {
        // val localVariableBody = calendarItemDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = calendarItemDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/calendarItem",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update delegations in calendarItems
     *
     * @param icureStubDto
     * @return kotlin.collections.List<CalendarItemDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun setCalendarItemsDelegations(icureStubDto: List<IcureStubDto>): List<CalendarItemDto> {
        val localVariableConfig = setCalendarItemsDelegationsRequestConfig(icureStubDto = icureStubDto)

        return request<List<IcureStubDto>, List<CalendarItemDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation setCalendarItemsDelegations
     *
     * @param icureStubDto
     * @return RequestConfig
     */
    fun setCalendarItemsDelegationsRequestConfig(icureStubDto: List<IcureStubDto>): RequestConfig<List<IcureStubDto>> {
        // val localVariableBody = icureStubDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = icureStubDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/calendarItem/delegations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
