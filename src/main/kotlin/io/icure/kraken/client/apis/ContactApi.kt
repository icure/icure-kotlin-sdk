/**
 * iCure Data Stack API Documentation
 *
 * The iCure Data Stack Application API is the native interface to iCure.
 *
 * The version of the OpenAPI document: v2
 *
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
package io.icure.kraken.client.apis


import io.icure.asyncjacksonhttpclient.net.web.WebClient
import io.icure.asyncjacksonhttpclient.netty.NettyWebClient
import io.icure.kraken.client.infrastructure.*
import org.taktik.icure.services.external.rest.v2.dto.ContactDto
import org.taktik.icure.services.external.rest.v2.dto.embed.ContentDto
import org.taktik.icure.services.external.rest.v2.dto.embed.DelegationDto
import io.icure.kraken.client.models.DocIdentifier
import org.taktik.icure.services.external.rest.v2.dto.IcureStubDto
import org.taktik.icure.services.external.rest.v2.dto.ListOfIdsDto
import io.icure.kraken.client.models.PaginatedListContactDto
import io.icure.kraken.client.models.PaginatedListServiceDto
import io.icure.kraken.client.security.AuthProvider
import io.icure.kraken.client.security.NoAuthProvider
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.taktik.icure.services.external.rest.v2.dto.data.LabelledOccurenceDto
import org.taktik.icure.services.external.rest.v2.dto.embed.ServiceDto
import java.net.URLEncoder
import java.util.*
import javax.inject.Named

@Named
@ExperimentalStdlibApi
@ExperimentalCoroutinesApi
class ContactApi(
    basePath: String = defaultBasePath,
    webClient: WebClient = NettyWebClient(),
    authProvider: AuthProvider = NoAuthProvider()
) : ApiClient(basePath, webClient, authProvider) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("io.icure.kraken.client.baseUrl", "https://kraken.icure.dev")
        }
    }

    /**
     * Close contacts for Healthcare Party and secret foreign keys.
     * Keys must be delimited by coma
     * @param hcPartyId
     * @param secretFKeys
     * @return kotlin.collections.List<ContactDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun closeForHCPartyPatientForeignKeys(
        hcPartyId: String,
        secretFKeys: String
    ): List<ContactDto> {
        val localVariableConfig =
            closeForHCPartyPatientForeignKeysRequestConfig(hcPartyId = hcPartyId, secretFKeys = secretFKeys)

        return request<Unit, List<ContactDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation closeForHCPartyPatientForeignKeys
     *
     * @param hcPartyId
     * @param secretFKeys
     * @return RequestConfig
     */
    fun closeForHCPartyPatientForeignKeysRequestConfig(
        hcPartyId: String,
        secretFKeys: String
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId))
                put("secretFKeys", listOf(secretFKeys))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/contact/byHcPartySecretForeignKeys/close",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create a contact with the current user
     * Returns an instance of created contact.
     * @param contactDto
     * @return ContactDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createContact(contactDto: ContactDto): ContactDto {
        val localVariableConfig = createContactRequestConfig(contactDto = contactDto)

        return request<ContactDto, ContactDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation createContact
     *
     * @param contactDto
     * @return RequestConfig
     */
    fun createContactRequestConfig(contactDto: ContactDto): RequestConfig<ContactDto> {
        // val localVariableBody = contactDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = contactDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create a batch of contacts
     * Returns the modified contacts.
     * @param contactDto
     * @return kotlin.collections.List<ContactDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createContacts(contactDto: List<ContactDto>): List<ContactDto> {
        val localVariableConfig = createContactsRequestConfig(contactDto = contactDto)

        return request<List<ContactDto>, List<ContactDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation createContacts
     *
     * @param contactDto
     * @return RequestConfig
     */
    fun createContactsRequestConfig(contactDto: List<ContactDto>): RequestConfig<List<ContactDto>> {
        // val localVariableBody = contactDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = contactDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete contacts.
     * Response is a set containing the ID&#39;s of deleted contacts.
     * @param listOfIdsDto
     * @return kotlin.collections.List<DocIdentifier>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteContacts(listOfIdsDto: ListOfIdsDto): List<DocIdentifier> {
        val localVariableConfig = deleteContactsRequestConfig(listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, List<DocIdentifier>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation deleteContacts
     *
     * @param listOfIdsDto
     * @return RequestConfig
     */
    fun deleteContactsRequestConfig(listOfIdsDto: ListOfIdsDto): RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact/delete/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List contacts for the current user (HcParty) or the given hcparty in the filter
     * Returns a list of contacts along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
     * @param filterChainContact
     * @param startDocumentId A Contact document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListContactDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filterContactsBy(
        filterChainContact: io.icure.kraken.client.models.filter.chain.FilterChain<ContactDto>,
        startDocumentId: String?,
        limit: Int?
    ): PaginatedListContactDto {
        val localVariableConfig = filterContactsByRequestConfig(
            filterChainContact = filterChainContact,
            startDocumentId = startDocumentId,
            limit = limit
        )

        return request<io.icure.kraken.client.models.filter.chain.FilterChain<ContactDto>, PaginatedListContactDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation filterContactsBy
     *
     * @param filterChainContact
     * @param startDocumentId A Contact document ID (optional)
     * @param limit Number of rows (optional)
     * @return RequestConfig
     */
    fun filterContactsByRequestConfig(
        filterChainContact: io.icure.kraken.client.models.filter.chain.FilterChain<ContactDto>,
        startDocumentId: String?,
        limit: Int?
    ): RequestConfig<io.icure.kraken.client.models.filter.chain.FilterChain<ContactDto>> {
        // val localVariableBody = filterChainContact
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = filterChainContact

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact/filter",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List services for the current user (HcParty) or the given hcparty in the filter
     * Returns a list of contacts along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
     * @param filterChainService
     * @param startDocumentId A Contact document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListServiceDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filterServicesBy(
        filterChainService: io.icure.kraken.client.models.filter.chain.FilterChain<ServiceDto>,
        startDocumentId: String?,
        limit: Int?
    ): PaginatedListServiceDto {
        val localVariableConfig = filterServicesByRequestConfig(
            filterChainService = filterChainService,
            startDocumentId = startDocumentId,
            limit = limit
        )

        return request<io.icure.kraken.client.models.filter.chain.FilterChain<ServiceDto>, PaginatedListServiceDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation filterServicesBy
     *
     * @param filterChainService
     * @param startDocumentId A Contact document ID (optional)
     * @param limit Number of rows (optional)
     * @return RequestConfig
     */
    fun filterServicesByRequestConfig(
        filterChainService: io.icure.kraken.client.models.filter.chain.FilterChain<ServiceDto>,
        startDocumentId: String?,
        limit: Int?
    ): RequestConfig<io.icure.kraken.client.models.filter.chain.FilterChain<ServiceDto>> {
        // val localVariableBody = filterChainService
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = filterChainService

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact/service/filter",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List contacts by opening date parties with(out) pagination
     * Returns a list of contacts.
     * @param startKey The contact openingDate
     * @param endKey The contact max openingDate
     * @param hcpartyid hcpartyid
     * @param startDocumentId A contact party document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListContactDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findContactsByOpeningDate(
        startKey: Long,
        endKey: Long,
        hcpartyid: String,
        startDocumentId: String?,
        limit: Int?
    ): PaginatedListContactDto {
        val localVariableConfig = findContactsByOpeningDateRequestConfig(
            startKey = startKey,
            endKey = endKey,
            hcpartyid = hcpartyid,
            startDocumentId = startDocumentId,
            limit = limit
        )

        return request<Unit, PaginatedListContactDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation findContactsByOpeningDate
     *
     * @param startKey The contact openingDate
     * @param endKey The contact max openingDate
     * @param hcpartyid hcpartyid
     * @param startDocumentId A contact party document ID (optional)
     * @param limit Number of rows (optional)
     * @return RequestConfig
     */
    fun findContactsByOpeningDateRequestConfig(
        startKey: Long,
        endKey: Long,
        hcpartyid: String,
        startDocumentId: String?,
        limit: Int?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("startKey", listOf(startKey.toString()))
                put("endKey", listOf(endKey.toString()))
                put("hcpartyid", listOf(hcpartyid))
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/contact/byOpeningDate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get a contact
     *
     * @param contactId
     * @return ContactDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getContact(contactId: String): ContactDto {
        val localVariableConfig = getContactRequestConfig(contactId = contactId)

        return request<Unit, ContactDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getContact
     *
     * @param contactId
     * @return RequestConfig
     */
    fun getContactRequestConfig(contactId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/contact/{contactId}".replace(
                "{" + "contactId" + "}",
                URLEncoder.encode(contactId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get contacts
     *
     * @param listOfIdsDto
     * @return kotlin.collections.List<ContactDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getContacts(listOfIdsDto: ListOfIdsDto): List<ContactDto> {
        val localVariableConfig = getContactsRequestConfig(listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, List<ContactDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getContacts
     *
     * @param listOfIdsDto
     * @return RequestConfig
     */
    fun getContactsRequestConfig(listOfIdsDto: ListOfIdsDto): RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact/byIds",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get an empty content
     *
     * @return ContentDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getEmptyContent(): ContentDto {
        val localVariableConfig = getEmptyContentRequestConfig()

        return request<Unit, ContentDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getEmptyContent
     *
     * @return RequestConfig
     */
    fun getEmptyContentRequestConfig(): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/contact/service/content/empty",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get the list of all used codes frequencies in services
     *
     * @param codeType
     * @param minOccurences
     * @return kotlin.collections.List<LabelledOccurenceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getServiceCodesOccurences(
        codeType: String,
        minOccurences: Long
    ): List<LabelledOccurenceDto> {
        val localVariableConfig =
            getServiceCodesOccurencesRequestConfig(codeType = codeType, minOccurences = minOccurences)

        return request<Unit, List<LabelledOccurenceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getServiceCodesOccurences
     *
     * @param codeType
     * @param minOccurences
     * @return RequestConfig
     */
    fun getServiceCodesOccurencesRequestConfig(
        codeType: String,
        minOccurences: Long
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/contact/service/codes/{codeType}/{minOccurences}".replace(
                "{" + "codeType" + "}",
                URLEncoder.encode(codeType, Charsets.UTF_8)
            ).replace("{" + "minOccurences" + "}", URLEncoder.encode(minOccurences.toString(), Charsets.UTF_8)),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List services with provided ids
     * Returns a list of services
     * @param listOfIdsDto
     * @return kotlin.collections.List<ServiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getServices(listOfIdsDto: ListOfIdsDto): List<ServiceDto> {
        val localVariableConfig = getServicesRequestConfig(listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, List<ServiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getServices
     *
     * @param listOfIdsDto
     * @return RequestConfig
     */
    fun getServicesRequestConfig(listOfIdsDto: ListOfIdsDto): RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact/service",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List services linked to provided ids
     * Returns a list of services
     * @param listOfIdsDto
     * @param linkType The type of the link (optional)
     * @return kotlin.collections.List<ServiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getServicesLinkedTo(
        listOfIdsDto: ListOfIdsDto,
        linkType: String?
    ): List<ServiceDto> {
        val localVariableConfig = getServicesLinkedToRequestConfig(listOfIdsDto = listOfIdsDto, linkType = linkType)

        return request<ListOfIdsDto, List<ServiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getServicesLinkedTo
     *
     * @param listOfIdsDto
     * @param linkType The type of the link (optional)
     * @return RequestConfig
     */
    fun getServicesLinkedToRequestConfig(
        listOfIdsDto: ListOfIdsDto,
        linkType: String?
    ): RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (linkType != null) {
                    put("linkType", listOf(linkType.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact/service/linkedTo",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List contacts found By Healthcare Party and service Id.
     *
     * @param hcPartyId
     * @param serviceId
     * @return kotlin.collections.List<ContactDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listContactByHCPartyServiceId(
        hcPartyId: String,
        serviceId: String
    ): List<ContactDto> {
        val localVariableConfig =
            listContactByHCPartyServiceIdRequestConfig(hcPartyId = hcPartyId, serviceId = serviceId)

        return request<Unit, List<ContactDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listContactByHCPartyServiceId
     *
     * @param hcPartyId
     * @param serviceId
     * @return RequestConfig
     */
    fun listContactByHCPartyServiceIdRequestConfig(
        hcPartyId: String,
        serviceId: String
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId))
                put("serviceId", listOf(serviceId))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/contact/byHcPartyServiceId",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List contacts found By externalId.
     *
     * @param externalId
     * @return kotlin.collections.List<ContactDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listContactsByExternalId(externalId: String): List<ContactDto> {
        val localVariableConfig = listContactsByExternalIdRequestConfig(externalId = externalId)

        return request<Unit, List<ContactDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listContactsByExternalId
     *
     * @param externalId
     * @return RequestConfig
     */
    fun listContactsByExternalIdRequestConfig(externalId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("externalId", listOf(externalId))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact/byExternalId",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List contacts found By Healthcare Party and form Id.
     *
     * @param hcPartyId
     * @param formId
     * @return kotlin.collections.List<ContactDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listContactsByHCPartyAndFormId(
        hcPartyId: String,
        formId: String
    ): List<ContactDto> {
        val localVariableConfig = listContactsByHCPartyAndFormIdRequestConfig(hcPartyId = hcPartyId, formId = formId)

        return request<Unit, List<ContactDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listContactsByHCPartyAndFormId
     *
     * @param hcPartyId
     * @param formId
     * @return RequestConfig
     */
    fun listContactsByHCPartyAndFormIdRequestConfig(
        hcPartyId: String,
        formId: String
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId))
                put("formId", listOf(formId))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/contact/byHcPartyFormId",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List contacts found By Healthcare Party and form Id.
     *
     * @param hcPartyId
     * @param listOfIdsDto
     * @return kotlin.collections.List<ContactDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listContactsByHCPartyAndFormIds(
        hcPartyId: String,
        listOfIdsDto: ListOfIdsDto
    ): List<ContactDto> {
        val localVariableConfig =
            listContactsByHCPartyAndFormIdsRequestConfig(hcPartyId = hcPartyId, listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, List<ContactDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listContactsByHCPartyAndFormIds
     *
     * @param hcPartyId
     * @param listOfIdsDto
     * @return RequestConfig
     */
    fun listContactsByHCPartyAndFormIdsRequestConfig(
        hcPartyId: String,
        listOfIdsDto: ListOfIdsDto
    ): RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact/byHcPartyFormIds",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List contacts found By Healthcare Party and Patient foreign keys.
     *
     * @param hcPartyId
     * @param listOfIdsDto
     * @return kotlin.collections.List<ContactDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listContactsByHCPartyAndPatientForeignKeys(
        hcPartyId: String,
        listOfIdsDto: ListOfIdsDto
    ): List<ContactDto> {
        val localVariableConfig =
            listContactsByHCPartyAndPatientForeignKeysRequestConfig(hcPartyId = hcPartyId, listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, List<ContactDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listContactsByHCPartyAndPatientForeignKeys
     *
     * @param hcPartyId
     * @param listOfIdsDto
     * @return RequestConfig
     */
    fun listContactsByHCPartyAndPatientForeignKeysRequestConfig(
        hcPartyId: String,
        listOfIdsDto: ListOfIdsDto
    ): RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact/byHcPartyPatientForeignKeys",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List contacts found By Healthcare Party and secret foreign keys.
     * Keys must be delimited by coma
     * @param hcPartyId
     * @param secretFKeys
     * @param planOfActionsIds  (optional)
     * @param skipClosedContacts  (optional)
     * @return kotlin.collections.List<ContactDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listContactsByHCPartyAndPatientSecretFKeys(
        hcPartyId: String,
        secretFKeys: String,
        planOfActionsIds: String?,
        skipClosedContacts: Boolean?
    ): List<ContactDto> {
        val localVariableConfig = listContactsByHCPartyAndPatientSecretFKeysRequestConfig(
            hcPartyId = hcPartyId,
            secretFKeys = secretFKeys,
            planOfActionsIds = planOfActionsIds,
            skipClosedContacts = skipClosedContacts
        )

        return request<Unit, List<ContactDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listContactsByHCPartyAndPatientSecretFKeys
     *
     * @param hcPartyId
     * @param secretFKeys
     * @param planOfActionsIds  (optional)
     * @param skipClosedContacts  (optional)
     * @return RequestConfig
     */
    fun listContactsByHCPartyAndPatientSecretFKeysRequestConfig(
        hcPartyId: String,
        secretFKeys: String,
        planOfActionsIds: String?,
        skipClosedContacts: Boolean?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId))
                put("secretFKeys", listOf(secretFKeys))
                if (planOfActionsIds != null) {
                    put("planOfActionsIds", listOf(planOfActionsIds.toString()))
                }
                if (skipClosedContacts != null) {
                    put("skipClosedContacts", listOf(skipClosedContacts.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/contact/byHcPartySecretForeignKeys",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List contacts found By Healthcare Party and secret foreign keys.
     * Keys must be delimited by coma
     * @param hcPartyId
     * @param secretFKeys
     * @return kotlin.collections.List<IcureStubDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listContactsDelegationsStubsByHCPartyAndPatientForeignKeys(
        hcPartyId: String,
        secretFKeys: String
    ): List<IcureStubDto> {
        val localVariableConfig = listContactsDelegationsStubsByHCPartyAndPatientForeignKeysRequestConfig(
            hcPartyId = hcPartyId,
            secretFKeys = secretFKeys
        )

        return request<Unit, List<IcureStubDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listContactsDelegationsStubsByHCPartyAndPatientForeignKeys
     *
     * @param hcPartyId
     * @param secretFKeys
     * @return RequestConfig
     */
    fun listContactsDelegationsStubsByHCPartyAndPatientForeignKeysRequestConfig(
        hcPartyId: String,
        secretFKeys: String
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId))
                put("secretFKeys", listOf(secretFKeys))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/contact/byHcPartySecretForeignKeys/delegations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List services by related association id
     * Returns a list of services
     * @param associationId
     * @return kotlin.collections.List<ServiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listServicesByAssociationId(associationId: String): List<ServiceDto> {
        val localVariableConfig = listServicesByAssociationIdRequestConfig(associationId = associationId)

        return request<Unit, List<ServiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listServicesByAssociationId
     *
     * @param associationId
     * @return RequestConfig
     */
    fun listServicesByAssociationIdRequestConfig(associationId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("associationId", listOf(associationId))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/contact/service/associationId",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List services linked to a health element
     * Returns the list of services linked to the provided health element id
     * @param healthElementId
     * @param hcPartyId hcPartyId
     * @return kotlin.collections.List<ServiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listServicesByHealthElementId(
        healthElementId: String,
        hcPartyId: String
    ): List<ServiceDto> {
        val localVariableConfig =
            listServicesByHealthElementIdRequestConfig(healthElementId = healthElementId, hcPartyId = hcPartyId)

        return request<Unit, List<ServiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listServicesByHealthElementId
     *
     * @param healthElementId
     * @param hcPartyId hcPartyId
     * @return RequestConfig
     */
    fun listServicesByHealthElementIdRequestConfig(
        healthElementId: String,
        hcPartyId: String
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/contact/service/healthElementId/{healthElementId}".replace(
                "{" + "healthElementId" + "}",
                URLEncoder.encode(healthElementId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get ids of contacts matching the provided filter for the current user (HcParty)
     *
     * @param abstractFilterDtoContact
     * @return kotlin.collections.List<kotlin.String>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun matchContactsBy(abstractFilterDtoContact: io.icure.kraken.client.models.filter.AbstractFilterDto<ContactDto>): List<String> {
        val localVariableConfig = matchContactsByRequestConfig(abstractFilterDtoContact = abstractFilterDtoContact)

        return request<io.icure.kraken.client.models.filter.AbstractFilterDto<ContactDto>, List<String>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation matchContactsBy
     *
     * @param abstractFilterDtoContact
     * @return RequestConfig
     */
    fun matchContactsByRequestConfig(abstractFilterDtoContact: io.icure.kraken.client.models.filter.AbstractFilterDto<ContactDto>): RequestConfig<io.icure.kraken.client.models.filter.AbstractFilterDto<ContactDto>> {
        // val localVariableBody = abstractFilterDtoContact
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = abstractFilterDtoContact

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact/match",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get ids of services matching the provided filter for the current user
     *
     * @param abstractFilterDtoService
     * @return kotlin.collections.List<kotlin.String>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun matchServicesBy(abstractFilterDtoService: io.icure.kraken.client.models.filter.AbstractFilterDto<ServiceDto>): List<String> {
        val localVariableConfig = matchServicesByRequestConfig(abstractFilterDtoService = abstractFilterDtoService)

        return request<io.icure.kraken.client.models.filter.AbstractFilterDto<ServiceDto>, List<String>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation matchServicesBy
     *
     * @param abstractFilterDtoService
     * @return RequestConfig
     */
    fun matchServicesByRequestConfig(abstractFilterDtoService: io.icure.kraken.client.models.filter.AbstractFilterDto<ServiceDto>): RequestConfig<io.icure.kraken.client.models.filter.AbstractFilterDto<ServiceDto>> {
        // val localVariableBody = abstractFilterDtoService
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = abstractFilterDtoService

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact/service/match",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Modify a contact
     * Returns the modified contact.
     * @param contactDto
     * @return ContactDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyContact(contactDto: ContactDto): ContactDto {
        val localVariableConfig = modifyContactRequestConfig(contactDto = contactDto)

        return request<ContactDto, ContactDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation modifyContact
     *
     * @param contactDto
     * @return RequestConfig
     */
    fun modifyContactRequestConfig(contactDto: ContactDto): RequestConfig<ContactDto> {
        // val localVariableBody = contactDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = contactDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/contact",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Modify a batch of contacts
     * Returns the modified contacts.
     * @param contactDto
     * @return kotlin.collections.List<ContactDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyContacts(contactDto: List<ContactDto>): List<ContactDto> {
        val localVariableConfig = modifyContactsRequestConfig(contactDto = contactDto)

        return request<List<ContactDto>, List<ContactDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation modifyContacts
     *
     * @param contactDto
     * @return RequestConfig
     */
    fun modifyContactsRequestConfig(contactDto: List<ContactDto>): RequestConfig<List<ContactDto>> {
        // val localVariableBody = contactDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = contactDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/contact/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update delegations in healthElements.
     * Keys must be delimited by coma
     * @param icureStubDto
     * @return kotlin.collections.List<ContactDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyContactsDelegations(icureStubDto: List<IcureStubDto>): List<ContactDto> {
        val localVariableConfig = modifyContactsDelegationsRequestConfig(icureStubDto = icureStubDto)

        return request<List<IcureStubDto>, List<ContactDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation modifyContactsDelegations
     *
     * @param icureStubDto
     * @return RequestConfig
     */
    fun modifyContactsDelegationsRequestConfig(icureStubDto: List<IcureStubDto>): RequestConfig<List<IcureStubDto>> {
        // val localVariableBody = icureStubDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = icureStubDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/contact/delegations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delegates a contact to a healthcare party
     * It delegates a contact to a healthcare party (By current healthcare party). Returns the contact with new delegations.
     * @param contactId
     * @param delegationDto
     * @return ContactDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun newContactDelegations(contactId: String, delegationDto: DelegationDto): ContactDto {
        val localVariableConfig =
            newContactDelegationsRequestConfig(contactId = contactId, delegationDto = delegationDto)

        return request<DelegationDto, ContactDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation newContactDelegations
     *
     * @param contactId
     * @param delegationDto
     * @return RequestConfig
     */
    fun newContactDelegationsRequestConfig(
        contactId: String,
        delegationDto: DelegationDto
    ): RequestConfig<DelegationDto> {
        // val localVariableBody = delegationDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = delegationDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact/{contactId}/delegate".replace(
                "{" + "contactId" + "}",
                URLEncoder.encode(contactId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update delegations in healthElements.
     * Keys must be delimited by coma
     * @param icureStubDto
     * @return kotlin.collections.List<ContactDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun setContactsDelegations(icureStubDto: List<IcureStubDto>): List<ContactDto> {
        val localVariableConfig = setContactsDelegationsRequestConfig(icureStubDto = icureStubDto)

        return request<List<IcureStubDto>, List<ContactDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation setContactsDelegations
     *
     * @param icureStubDto
     * @return RequestConfig
     */
    fun setContactsDelegationsRequestConfig(icureStubDto: List<IcureStubDto>): RequestConfig<List<IcureStubDto>> {
        // val localVariableBody = icureStubDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = icureStubDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/contact/delegations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
