/**
 * iCure Data Stack API Documentation
 *
 * The iCure Data Stack Application API is the native interface to iCure. This version is obsolete, please use v2.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
package io.icure.kraken.client.apis

import io.icure.asyncjacksonhttpclient.net.web.WebClient
import io.icure.asyncjacksonhttpclient.netty.NettyWebClient
import io.icure.kraken.client.models.DelegationDto
import io.icure.kraken.client.models.DocIdentifier
import io.icure.kraken.client.models.FormDto
import io.icure.kraken.client.models.FormTemplateDto
import io.icure.kraken.client.models.IcureStubDto
import io.icure.kraken.client.models.ListOfIdsDto

import kotlinx.coroutines.ExperimentalCoroutinesApi

import io.icure.kraken.client.infrastructure.ApiClient
import io.icure.kraken.client.infrastructure.ClientException
import io.icure.kraken.client.infrastructure.ServerException
import io.icure.kraken.client.infrastructure.MultiValueMap
import io.icure.kraken.client.infrastructure.RequestConfig
import io.icure.kraken.client.infrastructure.RequestMethod
import javax.inject.Named

@Named
@ExperimentalStdlibApi
@ExperimentalCoroutinesApi
class FormApi(basePath: kotlin.String = defaultBasePath, webClient: WebClient = NettyWebClient(), authHeader: String? = null) : ApiClient(basePath, webClient, authHeader) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("io.icure.kraken.client.baseUrl", "http://localhost:16043")
        }
    }

    /**
    * Create a form with the current user
    * Returns an instance of created form.
    * @param formDto  
    * @return FormDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createForm(formDto: FormDto) : FormDto?  {
        val localVariableConfig = createFormRequestConfig(formDto = formDto)

        return request<FormDto, FormDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createForm
    *
    * @param formDto  
    * @return RequestConfig
    */
    fun createFormRequestConfig(formDto: FormDto) : RequestConfig<FormDto> {
        val localVariableBody = formDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/form",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create a form template with the current user
    * Returns an instance of created form template.
    * @param formTemplateDto  
    * @return FormTemplateDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createFormTemplate(formTemplateDto: FormTemplateDto) : FormTemplateDto?  {
        val localVariableConfig = createFormTemplateRequestConfig(formTemplateDto = formTemplateDto)

        return request<FormTemplateDto, FormTemplateDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createFormTemplate
    *
    * @param formTemplateDto  
    * @return RequestConfig
    */
    fun createFormTemplateRequestConfig(formTemplateDto: FormTemplateDto) : RequestConfig<FormTemplateDto> {
        val localVariableBody = formTemplateDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/form/template",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create a batch of forms
    * Returns the created forms.
    * @param formDto  
    * @return kotlin.collections.List<FormDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createForms(formDto: kotlin.collections.List<FormDto>) : kotlin.collections.List<FormDto>?  {
        val localVariableConfig = createFormsRequestConfig(formDto = formDto)

        return request<kotlin.collections.List<FormDto>, kotlin.collections.List<FormDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createForms
    *
    * @param formDto  
    * @return RequestConfig
    */
    fun createFormsRequestConfig(formDto: kotlin.collections.List<FormDto>) : RequestConfig<kotlin.collections.List<FormDto>> {
        val localVariableBody = formDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/form/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete a form template
    * 
    * @param formTemplateId  
    * @return DocIdentifier
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteFormTemplate(formTemplateId: kotlin.String) : DocIdentifier?  {
        val localVariableConfig = deleteFormTemplateRequestConfig(formTemplateId = formTemplateId)

        return request<Unit, DocIdentifier>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteFormTemplate
    *
    * @param formTemplateId  
    * @return RequestConfig
    */
    fun deleteFormTemplateRequestConfig(formTemplateId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/rest/v1/form/template/{formTemplateId}".replace("{"+"formTemplateId"+"}", "$formTemplateId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete forms.
    * Response is a set containing the ID&#39;s of deleted forms.
    * @param formIds  
    * @return kotlin.collections.List<DocIdentifier>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteForms(formIds: kotlin.String) : kotlin.collections.List<DocIdentifier>?  {
        val localVariableConfig = deleteFormsRequestConfig(formIds = formIds)

        return request<Unit, kotlin.collections.List<DocIdentifier>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deleteForms
    *
    * @param formIds  
    * @return RequestConfig
    */
    fun deleteFormsRequestConfig(formIds: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/rest/v1/form/{formIds}".replace("{"+"formIds"+"}", "$formIds"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Gets all form templates for current user
    * 
    * @param loadLayout  (optional)
    * @return kotlin.collections.List<FormTemplateDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findFormTemplates(loadLayout: kotlin.Boolean?) : kotlin.collections.List<FormTemplateDto>?  {
        val localVariableConfig = findFormTemplatesRequestConfig(loadLayout = loadLayout)

        return request<Unit, kotlin.collections.List<FormTemplateDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findFormTemplates
    *
    * @param loadLayout  (optional)
    * @return RequestConfig
    */
    fun findFormTemplatesRequestConfig(loadLayout: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (loadLayout != null) {
                    put("loadLayout", listOf(loadLayout.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/form/template",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Gets all form templates
    * 
    * @param specialityCode  
    * @param loadLayout  (optional)
    * @return kotlin.collections.List<FormTemplateDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findFormTemplatesBySpeciality(specialityCode: kotlin.String, loadLayout: kotlin.Boolean?) : kotlin.collections.List<FormTemplateDto>?  {
        val localVariableConfig = findFormTemplatesBySpecialityRequestConfig(specialityCode = specialityCode, loadLayout = loadLayout)

        return request<Unit, kotlin.collections.List<FormTemplateDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findFormTemplatesBySpeciality
    *
    * @param specialityCode  
    * @param loadLayout  (optional)
    * @return RequestConfig
    */
    fun findFormTemplatesBySpecialityRequestConfig(specialityCode: kotlin.String, loadLayout: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (loadLayout != null) {
                    put("loadLayout", listOf(loadLayout.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/form/template/bySpecialty/{specialityCode}".replace("{"+"specialityCode"+"}", "$specialityCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * List forms found By Healthcare Party and secret foreign keys.
    * Keys must be delimited by coma
    * @param hcPartyId  
    * @param secretFKeys  
    * @param healthElementId  (optional)
    * @param planOfActionId  (optional)
    * @param formTemplateId  (optional)
    * @return kotlin.collections.List<FormDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findFormsByHCPartyPatientForeignKeys(hcPartyId: kotlin.String, secretFKeys: kotlin.String, healthElementId: kotlin.String?, planOfActionId: kotlin.String?, formTemplateId: kotlin.String?) : kotlin.collections.List<FormDto>?  {
        val localVariableConfig = findFormsByHCPartyPatientForeignKeysRequestConfig(hcPartyId = hcPartyId, secretFKeys = secretFKeys, healthElementId = healthElementId, planOfActionId = planOfActionId, formTemplateId = formTemplateId)

        return request<Unit, kotlin.collections.List<FormDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findFormsByHCPartyPatientForeignKeys
    *
    * @param hcPartyId  
    * @param secretFKeys  
    * @param healthElementId  (optional)
    * @param planOfActionId  (optional)
    * @param formTemplateId  (optional)
    * @return RequestConfig
    */
    fun findFormsByHCPartyPatientForeignKeysRequestConfig(hcPartyId: kotlin.String, secretFKeys: kotlin.String, healthElementId: kotlin.String?, planOfActionId: kotlin.String?, formTemplateId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId.toString()))
                put("secretFKeys", listOf(secretFKeys.toString()))
                if (healthElementId != null) {
                    put("healthElementId", listOf(healthElementId.toString()))
                }
                if (planOfActionId != null) {
                    put("planOfActionId", listOf(planOfActionId.toString()))
                }
                if (formTemplateId != null) {
                    put("formTemplateId", listOf(formTemplateId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/form/byHcPartySecretForeignKeys",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * List form stubs found By Healthcare Party and secret foreign keys.
    * Keys must be delimited by coma
    * @param hcPartyId  
    * @param secretFKeys  
    * @return kotlin.collections.List<IcureStubDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findFormsDelegationsStubsByHCPartyPatientForeignKeys(hcPartyId: kotlin.String, secretFKeys: kotlin.String) : kotlin.collections.List<IcureStubDto>?  {
        val localVariableConfig = findFormsDelegationsStubsByHCPartyPatientForeignKeysRequestConfig(hcPartyId = hcPartyId, secretFKeys = secretFKeys)

        return request<Unit, kotlin.collections.List<IcureStubDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findFormsDelegationsStubsByHCPartyPatientForeignKeys
    *
    * @param hcPartyId  
    * @param secretFKeys  
    * @return RequestConfig
    */
    fun findFormsDelegationsStubsByHCPartyPatientForeignKeysRequestConfig(hcPartyId: kotlin.String, secretFKeys: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId.toString()))
                put("secretFKeys", listOf(secretFKeys.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/form/byHcPartySecretForeignKeys/delegations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a list of forms by ids
    * Keys must be delimited by coma
    * @param formId  
    * @param hcPartyId  
    * @return kotlin.collections.List<FormDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getChildrenForms(formId: kotlin.String, hcPartyId: kotlin.String) : kotlin.collections.List<FormDto>?  {
        val localVariableConfig = getChildrenFormsRequestConfig(formId = formId, hcPartyId = hcPartyId)

        return request<Unit, kotlin.collections.List<FormDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getChildrenForms
    *
    * @param formId  
    * @param hcPartyId  
    * @return RequestConfig
    */
    fun getChildrenFormsRequestConfig(formId: kotlin.String, hcPartyId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/form/childrenOf/{formId}/{hcPartyId}".replace("{"+"formId"+"}", "$formId").replace("{"+"hcPartyId"+"}", "$hcPartyId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Gets a form
    * 
    * @param formId  
    * @return FormDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getForm(formId: kotlin.String) : FormDto?  {
        val localVariableConfig = getFormRequestConfig(formId = formId)

        return request<Unit, FormDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getForm
    *
    * @param formId  
    * @return RequestConfig
    */
    fun getFormRequestConfig(formId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/form/{formId}".replace("{"+"formId"+"}", "$formId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Gets the most recent form with the given logicalUuid
    * 
    * @param logicalUuid  
    * @return FormDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getFormByLogicalUuid(logicalUuid: kotlin.String) : FormDto?  {
        val localVariableConfig = getFormByLogicalUuidRequestConfig(logicalUuid = logicalUuid)

        return request<Unit, FormDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getFormByLogicalUuid
    *
    * @param logicalUuid  
    * @return RequestConfig
    */
    fun getFormByLogicalUuidRequestConfig(logicalUuid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/form/logicalUuid/{logicalUuid}".replace("{"+"logicalUuid"+"}", "$logicalUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Gets the most recent form with the given uniqueId
    * 
    * @param uniqueId  
    * @return FormDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getFormByUniqueId(uniqueId: kotlin.String) : FormDto?  {
        val localVariableConfig = getFormByUniqueIdRequestConfig(uniqueId = uniqueId)

        return request<Unit, FormDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getFormByUniqueId
    *
    * @param uniqueId  
    * @return RequestConfig
    */
    fun getFormByUniqueIdRequestConfig(uniqueId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/form/uniqueId/{uniqueId}".replace("{"+"uniqueId"+"}", "$uniqueId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Gets a form template by guid
    * 
    * @param formTemplateId  
    * @return FormTemplateDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getFormTemplate(formTemplateId: kotlin.String) : FormTemplateDto?  {
        val localVariableConfig = getFormTemplateRequestConfig(formTemplateId = formTemplateId)

        return request<Unit, FormTemplateDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getFormTemplate
    *
    * @param formTemplateId  
    * @return RequestConfig
    */
    fun getFormTemplateRequestConfig(formTemplateId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/form/template/{formTemplateId}".replace("{"+"formTemplateId"+"}", "$formTemplateId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Gets a form template
    * 
    * @param formTemplateGuid  
    * @param specialityCode  
    * @return kotlin.collections.List<FormTemplateDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getFormTemplatesByGuid(formTemplateGuid: kotlin.String, specialityCode: kotlin.String) : kotlin.collections.List<FormTemplateDto>?  {
        val localVariableConfig = getFormTemplatesByGuidRequestConfig(formTemplateGuid = formTemplateGuid, specialityCode = specialityCode)

        return request<Unit, kotlin.collections.List<FormTemplateDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getFormTemplatesByGuid
    *
    * @param formTemplateGuid  
    * @param specialityCode  
    * @return RequestConfig
    */
    fun getFormTemplatesByGuidRequestConfig(formTemplateGuid: kotlin.String, specialityCode: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/form/template/{specialityCode}/guid/{formTemplateGuid}".replace("{"+"formTemplateGuid"+"}", "$formTemplateGuid").replace("{"+"specialityCode"+"}", "$specialityCode"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get a list of forms by ids
    * Keys must be delimited by coma
    * @param listOfIdsDto  
    * @return kotlin.collections.List<FormDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getForms(listOfIdsDto: ListOfIdsDto) : kotlin.collections.List<FormDto>?  {
        val localVariableConfig = getFormsRequestConfig(listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, kotlin.collections.List<FormDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getForms
    *
    * @param listOfIdsDto  
    * @return RequestConfig
    */
    fun getFormsRequestConfig(listOfIdsDto: ListOfIdsDto) : RequestConfig<ListOfIdsDto> {
        val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/form/byIds",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Gets all forms with given logicalUuid
    * 
    * @param logicalUuid  
    * @return kotlin.collections.List<FormDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getFormsByLogicalUuid(logicalUuid: kotlin.String) : kotlin.collections.List<FormDto>?  {
        val localVariableConfig = getFormsByLogicalUuidRequestConfig(logicalUuid = logicalUuid)

        return request<Unit, kotlin.collections.List<FormDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getFormsByLogicalUuid
    *
    * @param logicalUuid  
    * @return RequestConfig
    */
    fun getFormsByLogicalUuidRequestConfig(logicalUuid: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/form/all/logicalUuid/{logicalUuid}".replace("{"+"logicalUuid"+"}", "$logicalUuid"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Gets all forms by uniqueId
    * 
    * @param uniqueId  
    * @return kotlin.collections.List<FormDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getFormsByUniqueId(uniqueId: kotlin.String) : kotlin.collections.List<FormDto>?  {
        val localVariableConfig = getFormsByUniqueIdRequestConfig(uniqueId = uniqueId)

        return request<Unit, kotlin.collections.List<FormDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getFormsByUniqueId
    *
    * @param uniqueId  
    * @return RequestConfig
    */
    fun getFormsByUniqueIdRequestConfig(uniqueId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/form/all/uniqueId/{uniqueId}".replace("{"+"uniqueId"+"}", "$uniqueId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Modify a form
    * Returns the modified form.
    * @param formDto  
    * @return FormDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyForm(formDto: FormDto) : FormDto?  {
        val localVariableConfig = modifyFormRequestConfig(formDto = formDto)

        return request<FormDto, FormDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation modifyForm
    *
    * @param formDto  
    * @return RequestConfig
    */
    fun modifyFormRequestConfig(formDto: FormDto) : RequestConfig<FormDto> {
        val localVariableBody = formDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v1/form",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Modify a batch of forms
    * Returns the modified forms.
    * @param formDto  
    * @return kotlin.collections.List<FormDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyForms(formDto: kotlin.collections.List<FormDto>) : kotlin.collections.List<FormDto>?  {
        val localVariableConfig = modifyFormsRequestConfig(formDto = formDto)

        return request<kotlin.collections.List<FormDto>, kotlin.collections.List<FormDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation modifyForms
    *
    * @param formDto  
    * @return RequestConfig
    */
    fun modifyFormsRequestConfig(formDto: kotlin.collections.List<FormDto>) : RequestConfig<kotlin.collections.List<FormDto>> {
        val localVariableBody = formDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v1/form/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delegates a form to a healthcare party
    * It delegates a form to a healthcare party. Returns the form with the new delegations.
    * @param formId  
    * @param delegationDto  
    * @return FormDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun newFormDelegations(formId: kotlin.String, delegationDto: kotlin.collections.List<DelegationDto>) : FormDto?  {
        val localVariableConfig = newFormDelegationsRequestConfig(formId = formId, delegationDto = delegationDto)

        return request<kotlin.collections.List<DelegationDto>, FormDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation newFormDelegations
    *
    * @param formId  
    * @param delegationDto  
    * @return RequestConfig
    */
    fun newFormDelegationsRequestConfig(formId: kotlin.String, delegationDto: kotlin.collections.List<DelegationDto>) : RequestConfig<kotlin.collections.List<DelegationDto>> {
        val localVariableBody = delegationDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/form/delegate/{formId}".replace("{"+"formId"+"}", "$formId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Update delegations in form.
    * Keys must be delimited by coma
    * @param icureStubDto  
    * @return kotlin.collections.List<IcureStubDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun setFormsDelegations(icureStubDto: kotlin.collections.List<IcureStubDto>) : kotlin.collections.List<IcureStubDto>?  {
        val localVariableConfig = setFormsDelegationsRequestConfig(icureStubDto = icureStubDto)

        return request<kotlin.collections.List<IcureStubDto>, kotlin.collections.List<IcureStubDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation setFormsDelegations
    *
    * @param icureStubDto  
    * @return RequestConfig
    */
    fun setFormsDelegationsRequestConfig(icureStubDto: kotlin.collections.List<IcureStubDto>) : RequestConfig<kotlin.collections.List<IcureStubDto>> {
        val localVariableBody = icureStubDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/form/delegations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Update a form template&#39;s layout
    * 
    * @param formTemplateId  
    * @param attachment  
    * @return kotlin.String
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun setTemplateAttachmentMulti(formTemplateId: kotlin.String, attachment: kotlin.collections.List<kotlin.ByteArray>) : kotlin.String?  {
        val localVariableConfig = setTemplateAttachmentMultiRequestConfig(formTemplateId = formTemplateId, attachment = attachment)

        return request<Map<String, Any?>, kotlin.String>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation setTemplateAttachmentMulti
    *
    * @param formTemplateId  
    * @param attachment  
    * @return RequestConfig
    */
    fun setTemplateAttachmentMultiRequestConfig(formTemplateId: kotlin.String, attachment: kotlin.collections.List<kotlin.ByteArray>) : RequestConfig<Map<String, Any?>> {
        val localVariableBody = mapOf("attachment" to attachment)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v1/form/template/{formTemplateId}/attachment/multipart".replace("{"+"formTemplateId"+"}", "$formTemplateId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Modify a form template with the current user
    * Returns an instance of created form template.
    * @param formTemplateId  
    * @param formTemplateDto  
    * @return FormTemplateDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateFormTemplate(formTemplateId: kotlin.String, formTemplateDto: FormTemplateDto) : FormTemplateDto?  {
        val localVariableConfig = updateFormTemplateRequestConfig(formTemplateId = formTemplateId, formTemplateDto = formTemplateDto)

        return request<FormTemplateDto, FormTemplateDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation updateFormTemplate
    *
    * @param formTemplateId  
    * @param formTemplateDto  
    * @return RequestConfig
    */
    fun updateFormTemplateRequestConfig(formTemplateId: kotlin.String, formTemplateDto: FormTemplateDto) : RequestConfig<FormTemplateDto> {
        val localVariableBody = formTemplateDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v1/form/template/{formTemplateId}".replace("{"+"formTemplateId"+"}", "$formTemplateId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
