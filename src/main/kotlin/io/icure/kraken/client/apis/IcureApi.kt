/**
 * iCure Data Stack API Documentation
 *
 * The iCure Data Stack Application API is the native interface to iCure.
 *
 * The version of the OpenAPI document: v2
 *
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
package io.icure.kraken.client.apis

import io.icure.asyncjacksonhttpclient.net.web.WebClient
import io.icure.asyncjacksonhttpclient.netty.NettyWebClient
import io.icure.kraken.client.infrastructure.*
import io.icure.kraken.client.security.AuthProvider
import io.icure.kraken.client.security.NoAuthProvider
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.taktik.icure.services.external.rest.v2.dto.*
import org.taktik.icure.services.external.rest.v2.dto.couchdb.ReplicatorDocumentDto
import java.net.URLEncoder
import java.util.*
import javax.inject.Named

@Named
@ExperimentalStdlibApi
@ExperimentalCoroutinesApi
class IcureApi(
    basePath: String = defaultBasePath,
    webClient: WebClient = NettyWebClient(),
    authProvider: AuthProvider = NoAuthProvider()
) : ApiClient(basePath, webClient, authProvider) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("io.icure.kraken.client.baseUrl", "https://kraken.icure.dev")
        }
    }

    /**
     * Get index info
     *
     * @return IndexingInfoDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getIndexingInfo(): IndexingInfoDto {
        val localVariableConfig = getIndexingInfoRequestConfig()

        return request<Unit, IndexingInfoDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getIndexingInfo
     *
     * @return RequestConfig
     */
    fun getIndexingInfoRequestConfig(): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/icure/i",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get process info
     *
     * @return kotlin.String
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getProcessInfo(): String {
        val localVariableConfig = getProcessInfoRequestConfig()

        return request<Unit, String>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getProcessInfo
     *
     * @return RequestConfig
     */
    fun getProcessInfoRequestConfig(): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/icure/p",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get replication info
     *
     * @return ReplicationInfoDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getReplicationInfo(): ReplicationInfoDto {
        val localVariableConfig = getReplicationInfoRequestConfig()

        return request<Unit, ReplicationInfoDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getReplicationInfo
     *
     * @return RequestConfig
     */
    fun getReplicationInfoRequestConfig(): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/icure/r",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get replication info
     *
     * @param id
     * @return ReplicatorDocumentDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getReplicatorInfo(id: String): ReplicatorDocumentDto {
        val localVariableConfig = getReplicatorInfoRequestConfig(id = id)

        return request<Unit, ReplicatorDocumentDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getReplicatorInfo
     *
     * @param id
     * @return RequestConfig
     */
    fun getReplicatorInfoRequestConfig(id: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/icure/r/{id}".replace(
                "{" + "id" + "}",
                URLEncoder.encode(id, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get user sync info
     *
     * @return kotlin.collections.Map<kotlin.String, kotlin.collections.Map<kotlin.String, kotlin.Any>>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getUserSyncInfo(): Map<String, Map<String, Any>> {
        val localVariableConfig = getUserSyncInfoRequestConfig()

        return request<Unit, Map<String, Map<String, Any>>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getUserSyncInfo
     *
     * @return RequestConfig
     */
    fun getUserSyncInfoRequestConfig(): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/icure/sync/user",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get version
     *
     * @return kotlin.String
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getVersion(): String {
        val localVariableConfig = getVersionRequestConfig()

        return request<Unit, String>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getVersion
     *
     * @return RequestConfig
     */
    fun getVersionRequestConfig(): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/icure/v",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Check if a user exists
     *
     * @return kotlin.String
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun isReady(): String {
        val localVariableConfig = isReadyRequestConfig()

        return request<Unit, String>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation isReady
     *
     * @return RequestConfig
     */
    fun isReadyRequestConfig(): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/icure/ok",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Resolve contacts conflicts
     *
     * @param limit  (optional)
     * @return kotlin.collections.List<ContactDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun resolveContactsConflicts(limit: Int?): List<ContactDto> {
        val localVariableConfig = resolveContactsConflictsRequestConfig(limit = limit)

        return request<Unit, List<ContactDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation resolveContactsConflicts
     *
     * @param limit  (optional)
     * @return RequestConfig
     */
    fun resolveContactsConflictsRequestConfig(limit: Int?): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/icure/conflicts/contact",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * resolve documents conflicts
     *
     * @param ids  (optional)
     * @param limit  (optional)
     * @return kotlin.collections.List<DocumentDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun resolveDocumentsConflicts(
        ids: String?,
        limit: Int?
    ): List<DocumentDto> {
        val localVariableConfig = resolveDocumentsConflictsRequestConfig(ids = ids, limit = limit)

        return request<Unit, List<DocumentDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation resolveDocumentsConflicts
     *
     * @param ids  (optional)
     * @param limit  (optional)
     * @return RequestConfig
     */
    fun resolveDocumentsConflictsRequestConfig(ids: String?, limit: Int?): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (ids != null) {
                    put("ids", listOf(ids.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/icure/conflicts/document",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * resolve forms conflicts
     *
     * @param limit  (optional)
     * @return kotlin.collections.List<FormDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun resolveFormsConflicts(limit: Int?): List<FormDto> {
        val localVariableConfig = resolveFormsConflictsRequestConfig(limit = limit)

        return request<Unit, List<FormDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation resolveFormsConflicts
     *
     * @param limit  (optional)
     * @return RequestConfig
     */
    fun resolveFormsConflictsRequestConfig(limit: Int?): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/icure/conflicts/form",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * resolve healthcare elements conflicts
     *
     * @param limit  (optional)
     * @return kotlin.collections.List<HealthElementDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun resolveHealthElementsConflicts(limit: Int?): List<HealthElementDto> {
        val localVariableConfig = resolveHealthElementsConflictsRequestConfig(limit = limit)

        return request<Unit, List<HealthElementDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation resolveHealthElementsConflicts
     *
     * @param limit  (optional)
     * @return RequestConfig
     */
    fun resolveHealthElementsConflictsRequestConfig(limit: Int?): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/icure/conflicts/healthelement",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * resolve invoices conflicts
     *
     * @param limit  (optional)
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun resolveInvoicesConflicts(limit: Int?): List<InvoiceDto> {
        val localVariableConfig = resolveInvoicesConflictsRequestConfig(limit = limit)

        return request<Unit, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation resolveInvoicesConflicts
     *
     * @param limit  (optional)
     * @return RequestConfig
     */
    fun resolveInvoicesConflictsRequestConfig(limit: Int?): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/icure/conflicts/invoice",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * resolve messages conflicts
     *
     * @param limit  (optional)
     * @return kotlin.collections.List<MessageDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun resolveMessagesConflicts(limit: Int?): List<MessageDto> {
        val localVariableConfig = resolveMessagesConflictsRequestConfig(limit = limit)

        return request<Unit, List<MessageDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation resolveMessagesConflicts
     *
     * @param limit  (optional)
     * @return RequestConfig
     */
    fun resolveMessagesConflictsRequestConfig(limit: Int?): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/icure/conflicts/message",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Resolve patients conflicts
     *
     * @param limit  (optional)
     * @return kotlin.collections.List<PatientDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun resolvePatientsConflicts(limit: Int?): List<PatientDto> {
        val localVariableConfig = resolvePatientsConflictsRequestConfig(limit = limit)

        return request<Unit, List<PatientDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation resolvePatientsConflicts
     *
     * @param limit  (optional)
     * @return RequestConfig
     */
    fun resolvePatientsConflictsRequestConfig(limit: Int?): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/icure/conflicts/patient",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Force update design doc
     *
     * @param entityName
     * @param warmup  (optional)
     * @return kotlin.Boolean
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateDesignDoc(entityName: String, warmup: Boolean?): Boolean {
        val localVariableConfig = updateDesignDocRequestConfig(entityName = entityName, warmup = warmup)

        return request<Unit, Boolean>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation updateDesignDoc
     *
     * @param entityName
     * @param warmup  (optional)
     * @return RequestConfig
     */
    fun updateDesignDocRequestConfig(entityName: String, warmup: Boolean?): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (warmup != null) {
                    put("warmup", listOf(warmup.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/icure/dd/{entityName}".replace(
                "{" + "entityName" + "}",
                URLEncoder.encode(entityName, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
