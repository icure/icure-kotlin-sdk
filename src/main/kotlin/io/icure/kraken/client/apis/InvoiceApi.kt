/**
 * iCure Data Stack API Documentation
 *
 * The iCure Data Stack Application API is the native interface to iCure.
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
package io.icure.kraken.client.apis

import io.icure.asyncjacksonhttpclient.net.web.WebClient
import io.icure.asyncjacksonhttpclient.netty.NettyWebClient
import io.icure.kraken.client.infrastructure.*
import io.icure.kraken.client.models.DelegationDto
import io.icure.kraken.client.models.DocIdentifier
import io.icure.kraken.client.models.FilterChainInvoice
import io.icure.kraken.client.models.IcureStubDto
import io.icure.kraken.client.models.InvoiceDto
import io.icure.kraken.client.models.InvoicingCodeDto
import io.icure.kraken.client.models.LabelledOccurenceDto
import io.icure.kraken.client.models.ListOfIdsDto
import io.icure.kraken.client.models.PaginatedListInvoiceDto

import kotlinx.coroutines.ExperimentalCoroutinesApi

import io.icure.kraken.client.infrastructure.ApiClient
import io.icure.kraken.client.infrastructure.ClientException
import io.icure.kraken.client.infrastructure.ServerException
import io.icure.kraken.client.infrastructure.MultiValueMap
import io.icure.kraken.client.infrastructure.RequestConfig
import io.icure.kraken.client.infrastructure.RequestMethod
import kotlinx.coroutines.flow.flowOf
import java.nio.ByteBuffer
import java.util.*
import javax.inject.Named
import kotlinx.coroutines.flow.Flow
import java.net.URLEncoder

@Named
@ExperimentalStdlibApi
@ExperimentalCoroutinesApi
class InvoiceApi(basePath: kotlin.String = defaultBasePath, webClient: WebClient = NettyWebClient(), authHeader: String? = null) : ApiClient(basePath, webClient, authHeader) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("io.icure.kraken.client.baseUrl", "https://kraken.icure.dev")
        }
    }

    /**
    * Gets all invoices for author at date
    * 
    * @param userId  
    * @param type  
    * @param sentMediumType  
    * @param secretFKeys  
    * @param invoicingCodeDto  
    * @param insuranceId  (optional)
    * @param invoiceId  (optional)
    * @param gracePeriod  (optional)
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun appendCodes(userId: kotlin.String, type: kotlin.String, sentMediumType: kotlin.String, secretFKeys: kotlin.String, invoicingCodeDto: kotlin.collections.List<InvoicingCodeDto>, insuranceId: kotlin.String?, invoiceId: kotlin.String?, gracePeriod: kotlin.Int?) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = appendCodesRequestConfig(userId = userId, type = type, sentMediumType = sentMediumType, secretFKeys = secretFKeys, invoicingCodeDto = invoicingCodeDto, insuranceId = insuranceId, invoiceId = invoiceId, gracePeriod = gracePeriod)

        return request<kotlin.collections.List<InvoicingCodeDto>, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation appendCodes
    *
    * @param userId  
    * @param type  
    * @param sentMediumType  
    * @param secretFKeys  
    * @param invoicingCodeDto  
    * @param insuranceId  (optional)
    * @param invoiceId  (optional)
    * @param gracePeriod  (optional)
    * @return RequestConfig
    */
    fun appendCodesRequestConfig(userId: kotlin.String, type: kotlin.String, sentMediumType: kotlin.String, secretFKeys: kotlin.String, invoicingCodeDto: kotlin.collections.List<InvoicingCodeDto>, insuranceId: kotlin.String?, invoiceId: kotlin.String?, gracePeriod: kotlin.Int?) : RequestConfig<kotlin.collections.List<InvoicingCodeDto>> {
        // val localVariableBody = invoicingCodeDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("secretFKeys", listOf(secretFKeys.toString()))
                if (insuranceId != null) {
                    put("insuranceId", listOf(insuranceId.toString()))
                }
                if (invoiceId != null) {
                    put("invoiceId", listOf(invoiceId.toString()))
                }
                if (gracePeriod != null) {
                    put("gracePeriod", listOf(gracePeriod.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = invoicingCodeDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/byauthor/{userId}/append/{type}/{sentMediumType}".replace("{"+"userId"+"}", "${URLEncoder.encode(userId.toString(), Charsets.UTF_8)}").replace("{"+"type"+"}", "${URLEncoder.encode(type.toString(), Charsets.UTF_8)}").replace("{"+"sentMediumType"+"}", "${URLEncoder.encode(sentMediumType.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Creates an invoice
    * 
    * @param invoiceDto  
    * @return InvoiceDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createInvoice(invoiceDto: InvoiceDto) : InvoiceDto  {
        val localVariableConfig = createInvoiceRequestConfig(invoiceDto = invoiceDto)

        return request<InvoiceDto, InvoiceDto>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation createInvoice
    *
    * @param invoiceDto  
    * @return RequestConfig
    */
    fun createInvoiceRequestConfig(invoiceDto: InvoiceDto) : RequestConfig<InvoiceDto> {
        // val localVariableBody = invoiceDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = invoiceDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Create a batch of invoices
    * Returns the created invoices.
    * @param invoiceDto  
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createInvoices(invoiceDto: kotlin.collections.List<InvoiceDto>) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = createInvoicesRequestConfig(invoiceDto = invoiceDto)

        return request<kotlin.collections.List<InvoiceDto>, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation createInvoices
    *
    * @param invoiceDto  
    * @return RequestConfig
    */
    fun createInvoicesRequestConfig(invoiceDto: kotlin.collections.List<InvoiceDto>) : RequestConfig<kotlin.collections.List<InvoiceDto>> {
        // val localVariableBody = invoiceDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = invoiceDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Deletes an invoice
    * 
    * @param invoiceId  
    * @return DocIdentifier
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteInvoice(invoiceId: kotlin.String) : DocIdentifier  {
        val localVariableConfig = deleteInvoiceRequestConfig(invoiceId = invoiceId)

        return request<Unit, DocIdentifier>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation deleteInvoice
    *
    * @param invoiceId  
    * @return RequestConfig
    */
    fun deleteInvoiceRequestConfig(invoiceId: kotlin.String) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/rest/v2/invoice/{invoiceId}".replace("{"+"invoiceId"+"}", "${URLEncoder.encode(invoiceId.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Filter invoices for the current user (HcParty)
    * Returns a list of invoices along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
    * @param filterChainInvoice  
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filterInvoicesBy(filterChainInvoice: FilterChainInvoice) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = filterInvoicesByRequestConfig(filterChainInvoice = filterChainInvoice)

        return request<FilterChainInvoice, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation filterInvoicesBy
    *
    * @param filterChainInvoice  
    * @return RequestConfig
    */
    fun filterInvoicesByRequestConfig(filterChainInvoice: FilterChainInvoice) : RequestConfig<FilterChainInvoice> {
        // val localVariableBody = filterChainInvoice
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = filterChainInvoice

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/filter",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Gets all invoices for author at date
    * 
    * @param hcPartyId  
    * @param fromDate  (optional)
    * @param toDate  (optional)
    * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @return PaginatedListInvoiceDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findInvoicesByAuthor(hcPartyId: kotlin.String, fromDate: kotlin.Long?, toDate: kotlin.Long?, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?) : PaginatedListInvoiceDto  {
        val localVariableConfig = findInvoicesByAuthorRequestConfig(hcPartyId = hcPartyId, fromDate = fromDate, toDate = toDate, startKey = startKey, startDocumentId = startDocumentId, limit = limit)

        return request<Unit, PaginatedListInvoiceDto>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation findInvoicesByAuthor
    *
    * @param hcPartyId  
    * @param fromDate  (optional)
    * @param toDate  (optional)
    * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @return RequestConfig
    */
    fun findInvoicesByAuthorRequestConfig(hcPartyId: kotlin.String, fromDate: kotlin.Long?, toDate: kotlin.Long?, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (fromDate != null) {
                    put("fromDate", listOf(fromDate.toString()))
                }
                if (toDate != null) {
                    put("toDate", listOf(toDate.toString()))
                }
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byauthor/{hcPartyId}".replace("{"+"hcPartyId"+"}", "${URLEncoder.encode(hcPartyId.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Gets an invoice
    * 
    * @param invoiceId  
    * @return InvoiceDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getInvoice(invoiceId: kotlin.String) : InvoiceDto  {
        val localVariableConfig = getInvoiceRequestConfig(invoiceId = invoiceId)

        return request<Unit, InvoiceDto>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation getInvoice
    *
    * @param invoiceId  
    * @return RequestConfig
    */
    fun getInvoiceRequestConfig(invoiceId: kotlin.String) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/{invoiceId}".replace("{"+"invoiceId"+"}", "${URLEncoder.encode(invoiceId.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Gets an invoice
    * 
    * @param listOfIdsDto  
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getInvoices(listOfIdsDto: ListOfIdsDto) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = getInvoicesRequestConfig(listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation getInvoices
    *
    * @param listOfIdsDto  
    * @return RequestConfig
    */
    fun getInvoicesRequestConfig(listOfIdsDto: ListOfIdsDto) : RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/byIds",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Get the list of all used tarifications frequencies in invoices
    * 
    * @param minOccurences  
    * @return kotlin.collections.List<LabelledOccurenceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getTarificationsCodesOccurences(minOccurences: kotlin.Long) : kotlin.collections.List<LabelledOccurenceDto>  {
        val localVariableConfig = getTarificationsCodesOccurencesRequestConfig(minOccurences = minOccurences)

        return request<Unit, kotlin.collections.List<LabelledOccurenceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation getTarificationsCodesOccurences
    *
    * @param minOccurences  
    * @return RequestConfig
    */
    fun getTarificationsCodesOccurencesRequestConfig(minOccurences: kotlin.Long) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/codes/{minOccurences}".replace("{"+"minOccurences"+"}", "${URLEncoder.encode(minOccurences.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Gets all invoices per status
    * 
    * @param status  
    * @param listOfIdsDto  
    * @param from  (optional)
    * @param to  (optional)
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listAllHcpsByStatus(status: kotlin.String, listOfIdsDto: ListOfIdsDto, from: kotlin.Long?, to: kotlin.Long?) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = listAllHcpsByStatusRequestConfig(status = status, listOfIdsDto = listOfIdsDto, from = from, to = to)

        return request<ListOfIdsDto, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation listAllHcpsByStatus
    *
    * @param status  
    * @param listOfIdsDto  
    * @param from  (optional)
    * @param to  (optional)
    * @return RequestConfig
    */
    fun listAllHcpsByStatusRequestConfig(status: kotlin.String, listOfIdsDto: ListOfIdsDto, from: kotlin.Long?, to: kotlin.Long?) : RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (from != null) {
                    put("from", listOf(from.toString()))
                }
                if (to != null) {
                    put("to", listOf(to.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/allHcpsByStatus/{status}".replace("{"+"status"+"}", "${URLEncoder.encode(status.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Gets all invoices for author at date
    * 
    * @param listOfIdsDto  
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByContactIds(listOfIdsDto: ListOfIdsDto) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = listInvoicesByContactIdsRequestConfig(listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation listInvoicesByContactIds
    *
    * @param listOfIdsDto  
    * @return RequestConfig
    */
    fun listInvoicesByContactIdsRequestConfig(listOfIdsDto: ListOfIdsDto) : RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/byContacts",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * List invoices found By Healthcare Party and secret foreign patient keys.
    * Keys have to delimited by coma
    * @param hcPartyId  
    * @param secretFKeys  
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByHCPartyAndPatientForeignKeys(hcPartyId: kotlin.String, secretFKeys: kotlin.String) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = listInvoicesByHCPartyAndPatientForeignKeysRequestConfig(hcPartyId = hcPartyId, secretFKeys = secretFKeys)

        return request<Unit, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation listInvoicesByHCPartyAndPatientForeignKeys
    *
    * @param hcPartyId  
    * @param secretFKeys  
    * @return RequestConfig
    */
    fun listInvoicesByHCPartyAndPatientForeignKeysRequestConfig(hcPartyId: kotlin.String, secretFKeys: kotlin.String) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId.toString()))
                put("secretFKeys", listOf(secretFKeys.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byHcPartySecretForeignKeys",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * List invoices by groupId
    * Keys have to delimited by coma
    * @param hcPartyId  
    * @param groupId  
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByHcPartyAndGroupId(hcPartyId: kotlin.String, groupId: kotlin.String) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = listInvoicesByHcPartyAndGroupIdRequestConfig(hcPartyId = hcPartyId, groupId = groupId)

        return request<Unit, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation listInvoicesByHcPartyAndGroupId
    *
    * @param hcPartyId  
    * @param groupId  
    * @return RequestConfig
    */
    fun listInvoicesByHcPartyAndGroupIdRequestConfig(hcPartyId: kotlin.String, groupId: kotlin.String) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byHcPartyGroupId/{hcPartyId}/{groupId}".replace("{"+"hcPartyId"+"}", "${URLEncoder.encode(hcPartyId.toString(), Charsets.UTF_8)}").replace("{"+"groupId"+"}", "${URLEncoder.encode(groupId.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * List invoices by type, sent or unsent
    * Keys have to delimited by coma
    * @param hcPartyId  
    * @param sentMediumType  
    * @param invoiceType  
    * @param sent  
    * @param from  (optional)
    * @param to  (optional)
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByHcPartySentMediumTypeInvoiceTypeSentDate(hcPartyId: kotlin.String, sentMediumType: kotlin.String, invoiceType: kotlin.String, sent: kotlin.Boolean, from: kotlin.Long?, to: kotlin.Long?) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = listInvoicesByHcPartySentMediumTypeInvoiceTypeSentDateRequestConfig(hcPartyId = hcPartyId, sentMediumType = sentMediumType, invoiceType = invoiceType, sent = sent, from = from, to = to)

        return request<Unit, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation listInvoicesByHcPartySentMediumTypeInvoiceTypeSentDate
    *
    * @param hcPartyId  
    * @param sentMediumType  
    * @param invoiceType  
    * @param sent  
    * @param from  (optional)
    * @param to  (optional)
    * @return RequestConfig
    */
    fun listInvoicesByHcPartySentMediumTypeInvoiceTypeSentDateRequestConfig(hcPartyId: kotlin.String, sentMediumType: kotlin.String, invoiceType: kotlin.String, sent: kotlin.Boolean, from: kotlin.Long?, to: kotlin.Long?) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (from != null) {
                    put("from", listOf(from.toString()))
                }
                if (to != null) {
                    put("to", listOf(to.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byHcParty/{hcPartyId}/mediumType/{sentMediumType}/invoiceType/{invoiceType}/sent/{sent}".replace("{"+"hcPartyId"+"}", "${URLEncoder.encode(hcPartyId.toString(), Charsets.UTF_8)}").replace("{"+"sentMediumType"+"}", "${URLEncoder.encode(sentMediumType.toString(), Charsets.UTF_8)}").replace("{"+"invoiceType"+"}", "${URLEncoder.encode(invoiceType.toString(), Charsets.UTF_8)}").replace("{"+"sent"+"}", "${URLEncoder.encode(sent.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Get all invoices by author, by sending mode, by status and by date
    * 
    * @param hcPartyId  
    * @param sendingMode  (optional)
    * @param status  (optional)
    * @param from  (optional)
    * @param to  (optional)
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByHcpartySendingModeStatusDate(hcPartyId: kotlin.String, sendingMode: kotlin.String?, status: kotlin.String?, from: kotlin.Long?, to: kotlin.Long?) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = listInvoicesByHcpartySendingModeStatusDateRequestConfig(hcPartyId = hcPartyId, sendingMode = sendingMode, status = status, from = from, to = to)

        return request<Unit, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation listInvoicesByHcpartySendingModeStatusDate
    *
    * @param hcPartyId  
    * @param sendingMode  (optional)
    * @param status  (optional)
    * @param from  (optional)
    * @param to  (optional)
    * @return RequestConfig
    */
    fun listInvoicesByHcpartySendingModeStatusDateRequestConfig(hcPartyId: kotlin.String, sendingMode: kotlin.String?, status: kotlin.String?, from: kotlin.Long?, to: kotlin.Long?) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (sendingMode != null) {
                    put("sendingMode", listOf(sendingMode.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (from != null) {
                    put("from", listOf(from.toString()))
                }
                if (to != null) {
                    put("to", listOf(to.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byHcpartySendingModeStatusDate/{hcPartyId}".replace("{"+"hcPartyId"+"}", "${URLEncoder.encode(hcPartyId.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Gets all invoices for author at date
    * 
    * @param invoiceIds  
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByIds(invoiceIds: kotlin.String) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = listInvoicesByIdsRequestConfig(invoiceIds = invoiceIds)

        return request<Unit, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation listInvoicesByIds
    *
    * @param invoiceIds  
    * @return RequestConfig
    */
    fun listInvoicesByIdsRequestConfig(invoiceIds: kotlin.String) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byIds/{invoiceIds}".replace("{"+"invoiceIds"+"}", "${URLEncoder.encode(invoiceIds.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Gets all invoices for author at date
    * 
    * @param recipientIds  
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByRecipientsIds(recipientIds: kotlin.String) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = listInvoicesByRecipientsIdsRequestConfig(recipientIds = recipientIds)

        return request<Unit, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation listInvoicesByRecipientsIds
    *
    * @param recipientIds  
    * @return RequestConfig
    */
    fun listInvoicesByRecipientsIdsRequestConfig(recipientIds: kotlin.String) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/to/{recipientIds}".replace("{"+"recipientIds"+"}", "${URLEncoder.encode(recipientIds.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Gets all invoices for author at date
    * 
    * @param serviceIds  
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByServiceIds(serviceIds: kotlin.String) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = listInvoicesByServiceIdsRequestConfig(serviceIds = serviceIds)

        return request<Unit, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation listInvoicesByServiceIds
    *
    * @param serviceIds  
    * @return RequestConfig
    */
    fun listInvoicesByServiceIdsRequestConfig(serviceIds: kotlin.String) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byServiceIds/{serviceIds}".replace("{"+"serviceIds"+"}", "${URLEncoder.encode(serviceIds.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * List helement stubs found By Healthcare Party and secret foreign keys.
    * Keys must be delimited by coma
    * @param hcPartyId  
    * @param secretFKeys  
    * @return kotlin.collections.List<IcureStubDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesDelegationsStubsByHCPartyAndPatientForeignKeys(hcPartyId: kotlin.String, secretFKeys: kotlin.String) : kotlin.collections.List<IcureStubDto>  {
        val localVariableConfig = listInvoicesDelegationsStubsByHCPartyAndPatientForeignKeysRequestConfig(hcPartyId = hcPartyId, secretFKeys = secretFKeys)

        return request<Unit, kotlin.collections.List<IcureStubDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation listInvoicesDelegationsStubsByHCPartyAndPatientForeignKeys
    *
    * @param hcPartyId  
    * @param secretFKeys  
    * @return RequestConfig
    */
    fun listInvoicesDelegationsStubsByHCPartyAndPatientForeignKeysRequestConfig(hcPartyId: kotlin.String, secretFKeys: kotlin.String) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId.toString()))
                put("secretFKeys", listOf(secretFKeys.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byHcPartySecretForeignKeys/delegations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Gets all invoices for author at date
    * 
    * @param userIds  (optional)
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listToInsurances(userIds: kotlin.String?) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = listToInsurancesRequestConfig(userIds = userIds)

        return request<Unit, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation listToInsurances
    *
    * @param userIds  (optional)
    * @return RequestConfig
    */
    fun listToInsurancesRequestConfig(userIds: kotlin.String?) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (userIds != null) {
                    put("userIds", listOf(userIds.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/toInsurances",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Gets all invoices for author at date
    * 
    * @param userIds  (optional)
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listToInsurancesUnsent(userIds: kotlin.String?) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = listToInsurancesUnsentRequestConfig(userIds = userIds)

        return request<Unit, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation listToInsurancesUnsent
    *
    * @param userIds  (optional)
    * @return RequestConfig
    */
    fun listToInsurancesUnsentRequestConfig(userIds: kotlin.String?) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (userIds != null) {
                    put("userIds", listOf(userIds.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/toInsurances/unsent",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Gets all invoices for author at date
    * 
    * @param hcPartyId  (optional)
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listToPatients(hcPartyId: kotlin.String?) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = listToPatientsRequestConfig(hcPartyId = hcPartyId)

        return request<Unit, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation listToPatients
    *
    * @param hcPartyId  (optional)
    * @return RequestConfig
    */
    fun listToPatientsRequestConfig(hcPartyId: kotlin.String?) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (hcPartyId != null) {
                    put("hcPartyId", listOf(hcPartyId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/toPatients",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Gets all invoices for author at date
    * 
    * @param hcPartyId  (optional)
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listToPatientsUnsent(hcPartyId: kotlin.String?) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = listToPatientsUnsentRequestConfig(hcPartyId = hcPartyId)

        return request<Unit, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation listToPatientsUnsent
    *
    * @param hcPartyId  (optional)
    * @return RequestConfig
    */
    fun listToPatientsUnsentRequestConfig(hcPartyId: kotlin.String?) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (hcPartyId != null) {
                    put("hcPartyId", listOf(hcPartyId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/toPatients/unsent",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Gets all invoices for author at date
    * 
    * @param invoiceId  
    * @param listOfIdsDto  
    * @return InvoiceDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun mergeTo(invoiceId: kotlin.String, listOfIdsDto: ListOfIdsDto) : InvoiceDto  {
        val localVariableConfig = mergeToRequestConfig(invoiceId = invoiceId, listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, InvoiceDto>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation mergeTo
    *
    * @param invoiceId  
    * @param listOfIdsDto  
    * @return RequestConfig
    */
    fun mergeToRequestConfig(invoiceId: kotlin.String, listOfIdsDto: ListOfIdsDto) : RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/mergeTo/{invoiceId}".replace("{"+"invoiceId"+"}", "${URLEncoder.encode(invoiceId.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Modifies an invoice
    * 
    * @param invoiceDto  
    * @return InvoiceDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyInvoice(invoiceDto: InvoiceDto) : InvoiceDto  {
        val localVariableConfig = modifyInvoiceRequestConfig(invoiceDto = invoiceDto)

        return request<InvoiceDto, InvoiceDto>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation modifyInvoice
    *
    * @param invoiceDto  
    * @return RequestConfig
    */
    fun modifyInvoiceRequestConfig(invoiceDto: InvoiceDto) : RequestConfig<InvoiceDto> {
        // val localVariableBody = invoiceDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = invoiceDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/invoice",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Modify a batch of invoices
    * Returns the modified invoices.
    * @param invoiceDto  
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyInvoices(invoiceDto: kotlin.collections.List<InvoiceDto>) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = modifyInvoicesRequestConfig(invoiceDto = invoiceDto)

        return request<kotlin.collections.List<InvoiceDto>, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation modifyInvoices
    *
    * @param invoiceDto  
    * @return RequestConfig
    */
    fun modifyInvoicesRequestConfig(invoiceDto: kotlin.collections.List<InvoiceDto>) : RequestConfig<kotlin.collections.List<InvoiceDto>> {
        // val localVariableBody = invoiceDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = invoiceDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/invoice/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Adds a delegation to a invoice
    * 
    * @param invoiceId  
    * @param delegationDto  
    * @return InvoiceDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun newInvoiceDelegations(invoiceId: kotlin.String, delegationDto: kotlin.collections.List<DelegationDto>) : InvoiceDto  {
        val localVariableConfig = newInvoiceDelegationsRequestConfig(invoiceId = invoiceId, delegationDto = delegationDto)

        return request<kotlin.collections.List<DelegationDto>, InvoiceDto>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation newInvoiceDelegations
    *
    * @param invoiceId  
    * @param delegationDto  
    * @return RequestConfig
    */
    fun newInvoiceDelegationsRequestConfig(invoiceId: kotlin.String, delegationDto: kotlin.collections.List<DelegationDto>) : RequestConfig<kotlin.collections.List<DelegationDto>> {
        // val localVariableBody = delegationDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = delegationDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/invoice/{invoiceId}/delegate".replace("{"+"invoiceId"+"}", "${URLEncoder.encode(invoiceId.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Modifies an invoice
    * 
    * @param invoiceDto  
    * @return InvoiceDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun reassignInvoice(invoiceDto: InvoiceDto) : InvoiceDto  {
        val localVariableConfig = reassignInvoiceRequestConfig(invoiceDto = invoiceDto)

        return request<InvoiceDto, InvoiceDto>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation reassignInvoice
    *
    * @param invoiceDto  
    * @return RequestConfig
    */
    fun reassignInvoiceRequestConfig(invoiceDto: InvoiceDto) : RequestConfig<InvoiceDto> {
        // val localVariableBody = invoiceDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = invoiceDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/reassign",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Remove an invoice of an user
    * 
    * @param userId  
    * @param serviceId  
    * @param secretFKeys  
    * @param requestBody  
    * @return kotlin.collections.List<InvoiceDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun removeCodes(userId: kotlin.String, serviceId: kotlin.String, secretFKeys: kotlin.String, requestBody: kotlin.collections.List<kotlin.String>) : kotlin.collections.List<InvoiceDto>  {
        val localVariableConfig = removeCodesRequestConfig(userId = userId, serviceId = serviceId, secretFKeys = secretFKeys, requestBody = requestBody)

        return request<kotlin.collections.List<kotlin.String>, kotlin.collections.List<InvoiceDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation removeCodes
    *
    * @param userId  
    * @param serviceId  
    * @param secretFKeys  
    * @param requestBody  
    * @return RequestConfig
    */
    fun removeCodesRequestConfig(userId: kotlin.String, serviceId: kotlin.String, secretFKeys: kotlin.String, requestBody: kotlin.collections.List<kotlin.String>) : RequestConfig<kotlin.collections.List<kotlin.String>> {
        // val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("secretFKeys", listOf(secretFKeys.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = requestBody

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/byauthor/{userId}/service/{serviceId}".replace("{"+"userId"+"}", "${URLEncoder.encode(userId.toString(), Charsets.UTF_8)}").replace("{"+"serviceId"+"}", "${URLEncoder.encode(serviceId.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Update delegations in healthElements.
    * Keys must be delimited by coma
    * @param icureStubDto  
    * @return kotlin.collections.List<IcureStubDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun setInvoicesDelegations(icureStubDto: kotlin.collections.List<IcureStubDto>) : kotlin.collections.List<IcureStubDto>  {
        val localVariableConfig = setInvoicesDelegationsRequestConfig(icureStubDto = icureStubDto)

        return request<kotlin.collections.List<IcureStubDto>, kotlin.collections.List<IcureStubDto>>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation setInvoicesDelegations
    *
    * @param icureStubDto  
    * @return RequestConfig
    */
    fun setInvoicesDelegationsRequestConfig(icureStubDto: kotlin.collections.List<IcureStubDto>) : RequestConfig<kotlin.collections.List<IcureStubDto>> {
        // val localVariableBody = icureStubDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = icureStubDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/delegations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

    /**
    * Gets all invoices for author at date
    * 
    * @param invoiceId  
    * @param scheme  
    * @param forcedValue  
    * @return InvoiceDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun validate(invoiceId: kotlin.String, scheme: kotlin.String, forcedValue: kotlin.String) : InvoiceDto  {
        val localVariableConfig = validateRequestConfig(invoiceId = invoiceId, scheme = scheme, forcedValue = forcedValue)

        return request<Unit, InvoiceDto>(
            localVariableConfig
        )!!
    }
    /**
    * To obtain the request config of the operation validate
    *
    * @param invoiceId  
    * @param scheme  
    * @param forcedValue  
    * @return RequestConfig
    */
    fun validateRequestConfig(invoiceId: kotlin.String, scheme: kotlin.String, forcedValue: kotlin.String) : RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("scheme", listOf(scheme.toString()))
                put("forcedValue", listOf(forcedValue.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/validate/{invoiceId}".replace("{"+"invoiceId"+"}", "${URLEncoder.encode(invoiceId.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody        )
    }

}
