/**
 * iCure Data Stack API Documentation
 *
 * The iCure Data Stack Application API is the native interface to iCure.
 *
 * The version of the OpenAPI document: v2
 *
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
package io.icure.kraken.client.apis

import io.icure.asyncjacksonhttpclient.net.web.WebClient
import io.icure.asyncjacksonhttpclient.netty.NettyWebClient
import io.icure.kraken.client.infrastructure.*
import org.taktik.icure.services.external.rest.v2.dto.embed.DelegationDto
import io.icure.kraken.client.models.DocIdentifier
import org.taktik.icure.services.external.rest.v2.dto.IcureStubDto
import org.taktik.icure.services.external.rest.v2.dto.ListOfIdsDto
import io.icure.kraken.client.models.PaginatedListInvoiceDto
import io.icure.kraken.client.security.AuthProvider
import io.icure.kraken.client.security.NoAuthProvider
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.taktik.icure.services.external.rest.v2.dto.InvoiceDto
import org.taktik.icure.services.external.rest.v2.dto.data.LabelledOccurenceDto
import org.taktik.icure.services.external.rest.v2.dto.embed.InvoicingCodeDto
import java.net.URLEncoder
import java.util.*
import javax.inject.Named

@Named
@ExperimentalStdlibApi
@ExperimentalCoroutinesApi
class InvoiceApi(
    basePath: String = defaultBasePath,
    webClient: WebClient = NettyWebClient(),
    authProvider: AuthProvider = NoAuthProvider()
) : ApiClient(basePath, webClient, authProvider) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("io.icure.kraken.client.baseUrl", "https://kraken.icure.dev")
        }
    }

    /**
     * Gets all invoices for author at date
     *
     * @param userId
     * @param type
     * @param sentMediumType
     * @param secretFKeys
     * @param invoicingCodeDto
     * @param insuranceId  (optional)
     * @param invoiceId  (optional)
     * @param gracePeriod  (optional)
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun appendCodes(
        userId: String,
        type: String,
        sentMediumType: String,
        secretFKeys: String,
        invoicingCodeDto: List<InvoicingCodeDto>,
        insuranceId: String?,
        invoiceId: String?,
        gracePeriod: Int?
    ): List<InvoiceDto> {
        val localVariableConfig = appendCodesRequestConfig(
            userId = userId,
            type = type,
            sentMediumType = sentMediumType,
            secretFKeys = secretFKeys,
            invoicingCodeDto = invoicingCodeDto,
            insuranceId = insuranceId,
            invoiceId = invoiceId,
            gracePeriod = gracePeriod
        )

        return request<List<InvoicingCodeDto>, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation appendCodes
     *
     * @param userId
     * @param type
     * @param sentMediumType
     * @param secretFKeys
     * @param invoicingCodeDto
     * @param insuranceId  (optional)
     * @param invoiceId  (optional)
     * @param gracePeriod  (optional)
     * @return RequestConfig
     */
    fun appendCodesRequestConfig(
        userId: String,
        type: String,
        sentMediumType: String,
        secretFKeys: String,
        invoicingCodeDto: List<InvoicingCodeDto>,
        insuranceId: String?,
        invoiceId: String?,
        gracePeriod: Int?
    ): RequestConfig<List<InvoicingCodeDto>> {
        // val localVariableBody = invoicingCodeDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("secretFKeys", listOf(secretFKeys))
                if (insuranceId != null) {
                    put("insuranceId", listOf(insuranceId.toString()))
                }
                if (invoiceId != null) {
                    put("invoiceId", listOf(invoiceId.toString()))
                }
                if (gracePeriod != null) {
                    put("gracePeriod", listOf(gracePeriod.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = invoicingCodeDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/byauthor/{userId}/append/{type}/{sentMediumType}".replace(
                "{" + "userId" + "}",
                URLEncoder.encode(userId, Charsets.UTF_8)
            ).replace("{" + "type" + "}", URLEncoder.encode(type, Charsets.UTF_8)).replace(
                "{" + "sentMediumType" + "}",
                URLEncoder.encode(sentMediumType, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Creates an invoice
     *
     * @param invoiceDto
     * @return InvoiceDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createInvoice(invoiceDto: InvoiceDto): InvoiceDto {
        val localVariableConfig = createInvoiceRequestConfig(invoiceDto = invoiceDto)

        return request<InvoiceDto, InvoiceDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation createInvoice
     *
     * @param invoiceDto
     * @return RequestConfig
     */
    fun createInvoiceRequestConfig(invoiceDto: InvoiceDto): RequestConfig<InvoiceDto> {
        // val localVariableBody = invoiceDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = invoiceDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create a batch of invoices
     * Returns the created invoices.
     * @param invoiceDto
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createInvoices(invoiceDto: List<InvoiceDto>): List<InvoiceDto> {
        val localVariableConfig = createInvoicesRequestConfig(invoiceDto = invoiceDto)

        return request<List<InvoiceDto>, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation createInvoices
     *
     * @param invoiceDto
     * @return RequestConfig
     */
    fun createInvoicesRequestConfig(invoiceDto: List<InvoiceDto>): RequestConfig<List<InvoiceDto>> {
        // val localVariableBody = invoiceDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = invoiceDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Deletes an invoice
     *
     * @param invoiceId
     * @return DocIdentifier
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteInvoice(invoiceId: String): DocIdentifier {
        val localVariableConfig = deleteInvoiceRequestConfig(invoiceId = invoiceId)

        return request<Unit, DocIdentifier>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation deleteInvoice
     *
     * @param invoiceId
     * @return RequestConfig
     */
    fun deleteInvoiceRequestConfig(invoiceId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/rest/v2/invoice/{invoiceId}".replace(
                "{" + "invoiceId" + "}",
                URLEncoder.encode(invoiceId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Filter invoices for the current user (HcParty)
     * Returns a list of invoices along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
     * @param filterChainInvoice
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filterInvoicesBy(filterChainInvoice: io.icure.kraken.client.models.filter.chain.FilterChain<InvoiceDto>): List<InvoiceDto> {
        val localVariableConfig = filterInvoicesByRequestConfig(filterChainInvoice = filterChainInvoice)

        return request<io.icure.kraken.client.models.filter.chain.FilterChain<InvoiceDto>, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation filterInvoicesBy
     *
     * @param filterChainInvoice
     * @return RequestConfig
     */
    fun filterInvoicesByRequestConfig(filterChainInvoice: io.icure.kraken.client.models.filter.chain.FilterChain<InvoiceDto>): RequestConfig<io.icure.kraken.client.models.filter.chain.FilterChain<InvoiceDto>> {
        // val localVariableBody = filterChainInvoice
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = filterChainInvoice

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/filter",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets all invoices for author at date
     *
     * @param hcPartyId
     * @param fromDate  (optional)
     * @param toDate  (optional)
     * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListInvoiceDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findInvoicesByAuthor(
        hcPartyId: String,
        fromDate: Long?,
        toDate: Long?,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?
    ): PaginatedListInvoiceDto {
        val localVariableConfig = findInvoicesByAuthorRequestConfig(
            hcPartyId = hcPartyId,
            fromDate = fromDate,
            toDate = toDate,
            startKey = startKey,
            startDocumentId = startDocumentId,
            limit = limit
        )

        return request<Unit, PaginatedListInvoiceDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation findInvoicesByAuthor
     *
     * @param hcPartyId
     * @param fromDate  (optional)
     * @param toDate  (optional)
     * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @return RequestConfig
     */
    fun findInvoicesByAuthorRequestConfig(
        hcPartyId: String,
        fromDate: Long?,
        toDate: Long?,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (fromDate != null) {
                    put("fromDate", listOf(fromDate.toString()))
                }
                if (toDate != null) {
                    put("toDate", listOf(toDate.toString()))
                }
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byauthor/{hcPartyId}".replace(
                "{" + "hcPartyId" + "}",
                URLEncoder.encode(hcPartyId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets an invoice
     *
     * @param invoiceId
     * @return InvoiceDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getInvoice(invoiceId: String): InvoiceDto {
        val localVariableConfig = getInvoiceRequestConfig(invoiceId = invoiceId)

        return request<Unit, InvoiceDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getInvoice
     *
     * @param invoiceId
     * @return RequestConfig
     */
    fun getInvoiceRequestConfig(invoiceId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/{invoiceId}".replace(
                "{" + "invoiceId" + "}",
                URLEncoder.encode(invoiceId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets an invoice
     *
     * @param listOfIdsDto
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getInvoices(listOfIdsDto: ListOfIdsDto): List<InvoiceDto> {
        val localVariableConfig = getInvoicesRequestConfig(listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getInvoices
     *
     * @param listOfIdsDto
     * @return RequestConfig
     */
    fun getInvoicesRequestConfig(listOfIdsDto: ListOfIdsDto): RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/byIds",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get the list of all used tarifications frequencies in invoices
     *
     * @param minOccurences
     * @return kotlin.collections.List<LabelledOccurenceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getTarificationsCodesOccurences(minOccurences: Long): List<LabelledOccurenceDto> {
        val localVariableConfig = getTarificationsCodesOccurencesRequestConfig(minOccurences = minOccurences)

        return request<Unit, List<LabelledOccurenceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getTarificationsCodesOccurences
     *
     * @param minOccurences
     * @return RequestConfig
     */
    fun getTarificationsCodesOccurencesRequestConfig(minOccurences: Long): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/codes/{minOccurences}".replace(
                "{" + "minOccurences" + "}",
                URLEncoder.encode(minOccurences.toString(), Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets all invoices per status
     *
     * @param status
     * @param listOfIdsDto
     * @param from  (optional)
     * @param to  (optional)
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listAllHcpsByStatus(
        status: String,
        listOfIdsDto: ListOfIdsDto,
        from: Long?,
        to: Long?
    ): List<InvoiceDto> {
        val localVariableConfig =
            listAllHcpsByStatusRequestConfig(status = status, listOfIdsDto = listOfIdsDto, from = from, to = to)

        return request<ListOfIdsDto, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listAllHcpsByStatus
     *
     * @param status
     * @param listOfIdsDto
     * @param from  (optional)
     * @param to  (optional)
     * @return RequestConfig
     */
    fun listAllHcpsByStatusRequestConfig(
        status: String,
        listOfIdsDto: ListOfIdsDto,
        from: Long?,
        to: Long?
    ): RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (from != null) {
                    put("from", listOf(from.toString()))
                }
                if (to != null) {
                    put("to", listOf(to.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/allHcpsByStatus/{status}".replace(
                "{" + "status" + "}",
                URLEncoder.encode(status, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets all invoices for author at date
     *
     * @param listOfIdsDto
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByContactIds(listOfIdsDto: ListOfIdsDto): List<InvoiceDto> {
        val localVariableConfig = listInvoicesByContactIdsRequestConfig(listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listInvoicesByContactIds
     *
     * @param listOfIdsDto
     * @return RequestConfig
     */
    fun listInvoicesByContactIdsRequestConfig(listOfIdsDto: ListOfIdsDto): RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/byContacts",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List invoices found By Healthcare Party and secret foreign patient keys.
     * Keys have to delimited by coma
     * @param hcPartyId
     * @param secretFKeys
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByHCPartyAndPatientForeignKeys(
        hcPartyId: String,
        secretFKeys: String
    ): List<InvoiceDto> {
        val localVariableConfig =
            listInvoicesByHCPartyAndPatientForeignKeysRequestConfig(hcPartyId = hcPartyId, secretFKeys = secretFKeys)

        return request<Unit, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listInvoicesByHCPartyAndPatientForeignKeys
     *
     * @param hcPartyId
     * @param secretFKeys
     * @return RequestConfig
     */
    fun listInvoicesByHCPartyAndPatientForeignKeysRequestConfig(
        hcPartyId: String,
        secretFKeys: String
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId))
                put("secretFKeys", listOf(secretFKeys))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byHcPartySecretForeignKeys",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List invoices by groupId
     * Keys have to delimited by coma
     * @param hcPartyId
     * @param groupId
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByHcPartyAndGroupId(
        hcPartyId: String,
        groupId: String
    ): List<InvoiceDto> {
        val localVariableConfig = listInvoicesByHcPartyAndGroupIdRequestConfig(hcPartyId = hcPartyId, groupId = groupId)

        return request<Unit, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listInvoicesByHcPartyAndGroupId
     *
     * @param hcPartyId
     * @param groupId
     * @return RequestConfig
     */
    fun listInvoicesByHcPartyAndGroupIdRequestConfig(
        hcPartyId: String,
        groupId: String
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byHcPartyGroupId/{hcPartyId}/{groupId}".replace(
                "{" + "hcPartyId" + "}",
                URLEncoder.encode(hcPartyId, Charsets.UTF_8)
            ).replace("{" + "groupId" + "}", URLEncoder.encode(groupId, Charsets.UTF_8)),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List invoices by type, sent or unsent
     * Keys have to delimited by coma
     * @param hcPartyId
     * @param sentMediumType
     * @param invoiceType
     * @param sent
     * @param from  (optional)
     * @param to  (optional)
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByHcPartySentMediumTypeInvoiceTypeSentDate(
        hcPartyId: String,
        sentMediumType: String,
        invoiceType: String,
        sent: Boolean,
        from: Long?,
        to: Long?
    ): List<InvoiceDto> {
        val localVariableConfig = listInvoicesByHcPartySentMediumTypeInvoiceTypeSentDateRequestConfig(
            hcPartyId = hcPartyId,
            sentMediumType = sentMediumType,
            invoiceType = invoiceType,
            sent = sent,
            from = from,
            to = to
        )

        return request<Unit, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listInvoicesByHcPartySentMediumTypeInvoiceTypeSentDate
     *
     * @param hcPartyId
     * @param sentMediumType
     * @param invoiceType
     * @param sent
     * @param from  (optional)
     * @param to  (optional)
     * @return RequestConfig
     */
    fun listInvoicesByHcPartySentMediumTypeInvoiceTypeSentDateRequestConfig(
        hcPartyId: String,
        sentMediumType: String,
        invoiceType: String,
        sent: Boolean,
        from: Long?,
        to: Long?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (from != null) {
                    put("from", listOf(from.toString()))
                }
                if (to != null) {
                    put("to", listOf(to.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byHcParty/{hcPartyId}/mediumType/{sentMediumType}/invoiceType/{invoiceType}/sent/{sent}".replace(
                "{" + "hcPartyId" + "}",
                URLEncoder.encode(hcPartyId, Charsets.UTF_8)
            ).replace("{" + "sentMediumType" + "}", URLEncoder.encode(sentMediumType, Charsets.UTF_8))
                .replace("{" + "invoiceType" + "}", "${URLEncoder.encode(invoiceType, Charsets.UTF_8)}")
                .replace("{" + "sent" + "}", URLEncoder.encode(sent.toString(), Charsets.UTF_8)),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get all invoices by author, by sending mode, by status and by date
     *
     * @param hcPartyId
     * @param sendingMode  (optional)
     * @param status  (optional)
     * @param from  (optional)
     * @param to  (optional)
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByHcpartySendingModeStatusDate(
        hcPartyId: String,
        sendingMode: String?,
        status: String?,
        from: Long?,
        to: Long?
    ): List<InvoiceDto> {
        val localVariableConfig = listInvoicesByHcpartySendingModeStatusDateRequestConfig(
            hcPartyId = hcPartyId,
            sendingMode = sendingMode,
            status = status,
            from = from,
            to = to
        )

        return request<Unit, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listInvoicesByHcpartySendingModeStatusDate
     *
     * @param hcPartyId
     * @param sendingMode  (optional)
     * @param status  (optional)
     * @param from  (optional)
     * @param to  (optional)
     * @return RequestConfig
     */
    fun listInvoicesByHcpartySendingModeStatusDateRequestConfig(
        hcPartyId: String,
        sendingMode: String?,
        status: String?,
        from: Long?,
        to: Long?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (sendingMode != null) {
                    put("sendingMode", listOf(sendingMode.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (from != null) {
                    put("from", listOf(from.toString()))
                }
                if (to != null) {
                    put("to", listOf(to.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byHcpartySendingModeStatusDate/{hcPartyId}".replace(
                "{" + "hcPartyId" + "}",
                URLEncoder.encode(hcPartyId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets all invoices for author at date
     *
     * @param invoiceIds
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByIds(invoiceIds: String): List<InvoiceDto> {
        val localVariableConfig = listInvoicesByIdsRequestConfig(invoiceIds = invoiceIds)

        return request<Unit, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listInvoicesByIds
     *
     * @param invoiceIds
     * @return RequestConfig
     */
    fun listInvoicesByIdsRequestConfig(invoiceIds: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byIds/{invoiceIds}".replace(
                "{" + "invoiceIds" + "}",
                URLEncoder.encode(invoiceIds.toString(), Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets all invoices for author at date
     *
     * @param recipientIds
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByRecipientsIds(recipientIds: String): List<InvoiceDto> {
        val localVariableConfig = listInvoicesByRecipientsIdsRequestConfig(recipientIds = recipientIds)

        return request<Unit, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listInvoicesByRecipientsIds
     *
     * @param recipientIds
     * @return RequestConfig
     */
    fun listInvoicesByRecipientsIdsRequestConfig(recipientIds: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/to/{recipientIds}".replace(
                "{" + "recipientIds" + "}",
                "${URLEncoder.encode(recipientIds, Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets all invoices for author at date
     *
     * @param serviceIds
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesByServiceIds(serviceIds: String): List<InvoiceDto> {
        val localVariableConfig = listInvoicesByServiceIdsRequestConfig(serviceIds = serviceIds)

        return request<Unit, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listInvoicesByServiceIds
     *
     * @param serviceIds
     * @return RequestConfig
     */
    fun listInvoicesByServiceIdsRequestConfig(serviceIds: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byServiceIds/{serviceIds}".replace(
                "{" + "serviceIds" + "}",
                "${URLEncoder.encode(serviceIds.toString(), Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List helement stubs found By Healthcare Party and secret foreign keys.
     * Keys must be delimited by coma
     * @param hcPartyId
     * @param secretFKeys
     * @return kotlin.collections.List<IcureStubDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listInvoicesDelegationsStubsByHCPartyAndPatientForeignKeys(
        hcPartyId: String,
        secretFKeys: String
    ): List<IcureStubDto> {
        val localVariableConfig = listInvoicesDelegationsStubsByHCPartyAndPatientForeignKeysRequestConfig(
            hcPartyId = hcPartyId,
            secretFKeys = secretFKeys
        )

        return request<Unit, List<IcureStubDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listInvoicesDelegationsStubsByHCPartyAndPatientForeignKeys
     *
     * @param hcPartyId
     * @param secretFKeys
     * @return RequestConfig
     */
    fun listInvoicesDelegationsStubsByHCPartyAndPatientForeignKeysRequestConfig(
        hcPartyId: String,
        secretFKeys: String
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId))
                put("secretFKeys", listOf(secretFKeys.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/byHcPartySecretForeignKeys/delegations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets all invoices for author at date
     *
     * @param userIds  (optional)
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listToInsurances(userIds: String?): List<InvoiceDto> {
        val localVariableConfig = listToInsurancesRequestConfig(userIds = userIds)

        return request<Unit, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listToInsurances
     *
     * @param userIds  (optional)
     * @return RequestConfig
     */
    fun listToInsurancesRequestConfig(userIds: String?): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (userIds != null) {
                    put("userIds", listOf(userIds.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/toInsurances",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets all invoices for author at date
     *
     * @param userIds  (optional)
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listToInsurancesUnsent(userIds: String?): List<InvoiceDto> {
        val localVariableConfig = listToInsurancesUnsentRequestConfig(userIds = userIds)

        return request<Unit, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listToInsurancesUnsent
     *
     * @param userIds  (optional)
     * @return RequestConfig
     */
    fun listToInsurancesUnsentRequestConfig(userIds: String?): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (userIds != null) {
                    put("userIds", listOf(userIds.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/toInsurances/unsent",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets all invoices for author at date
     *
     * @param hcPartyId  (optional)
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listToPatients(hcPartyId: String?): List<InvoiceDto> {
        val localVariableConfig = listToPatientsRequestConfig(hcPartyId = hcPartyId)

        return request<Unit, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listToPatients
     *
     * @param hcPartyId  (optional)
     * @return RequestConfig
     */
    fun listToPatientsRequestConfig(hcPartyId: String?): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (hcPartyId != null) {
                    put("hcPartyId", listOf(hcPartyId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/toPatients",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets all invoices for author at date
     *
     * @param hcPartyId  (optional)
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listToPatientsUnsent(hcPartyId: String?): List<InvoiceDto> {
        val localVariableConfig = listToPatientsUnsentRequestConfig(hcPartyId = hcPartyId)

        return request<Unit, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listToPatientsUnsent
     *
     * @param hcPartyId  (optional)
     * @return RequestConfig
     */
    fun listToPatientsUnsentRequestConfig(hcPartyId: String?): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (hcPartyId != null) {
                    put("hcPartyId", listOf(hcPartyId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/invoice/toPatients/unsent",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets all invoices for author at date
     *
     * @param invoiceId
     * @param listOfIdsDto
     * @return InvoiceDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun mergeTo(invoiceId: String, listOfIdsDto: ListOfIdsDto): InvoiceDto {
        val localVariableConfig = mergeToRequestConfig(invoiceId = invoiceId, listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, InvoiceDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation mergeTo
     *
     * @param invoiceId
     * @param listOfIdsDto
     * @return RequestConfig
     */
    fun mergeToRequestConfig(invoiceId: String, listOfIdsDto: ListOfIdsDto): RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/mergeTo/{invoiceId}".replace(
                "{" + "invoiceId" + "}",
                URLEncoder.encode(invoiceId.toString(), Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Modifies an invoice
     *
     * @param invoiceDto
     * @return InvoiceDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyInvoice(invoiceDto: InvoiceDto): InvoiceDto {
        val localVariableConfig = modifyInvoiceRequestConfig(invoiceDto = invoiceDto)

        return request<InvoiceDto, InvoiceDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation modifyInvoice
     *
     * @param invoiceDto
     * @return RequestConfig
     */
    fun modifyInvoiceRequestConfig(invoiceDto: InvoiceDto): RequestConfig<InvoiceDto> {
        // val localVariableBody = invoiceDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = invoiceDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/invoice",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Modify a batch of invoices
     * Returns the modified invoices.
     * @param invoiceDto
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyInvoices(invoiceDto: List<InvoiceDto>): List<InvoiceDto> {
        val localVariableConfig = modifyInvoicesRequestConfig(invoiceDto = invoiceDto)

        return request<List<InvoiceDto>, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation modifyInvoices
     *
     * @param invoiceDto
     * @return RequestConfig
     */
    fun modifyInvoicesRequestConfig(invoiceDto: List<InvoiceDto>): RequestConfig<List<InvoiceDto>> {
        // val localVariableBody = invoiceDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = invoiceDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/invoice/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Adds a delegation to a invoice
     *
     * @param invoiceId
     * @param delegationDto
     * @return InvoiceDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun newInvoiceDelegations(
        invoiceId: String,
        delegationDto: List<DelegationDto>
    ): InvoiceDto {
        val localVariableConfig =
            newInvoiceDelegationsRequestConfig(invoiceId = invoiceId, delegationDto = delegationDto)

        return request<List<DelegationDto>, InvoiceDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation newInvoiceDelegations
     *
     * @param invoiceId
     * @param delegationDto
     * @return RequestConfig
     */
    fun newInvoiceDelegationsRequestConfig(
        invoiceId: String,
        delegationDto: List<DelegationDto>
    ): RequestConfig<List<DelegationDto>> {
        // val localVariableBody = delegationDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = delegationDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/invoice/{invoiceId}/delegate".replace(
                "{" + "invoiceId" + "}",
                "${URLEncoder.encode(invoiceId.toString(), Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Modifies an invoice
     *
     * @param invoiceDto
     * @return InvoiceDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun reassignInvoice(invoiceDto: InvoiceDto): InvoiceDto {
        val localVariableConfig = reassignInvoiceRequestConfig(invoiceDto = invoiceDto)

        return request<InvoiceDto, InvoiceDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation reassignInvoice
     *
     * @param invoiceDto
     * @return RequestConfig
     */
    fun reassignInvoiceRequestConfig(invoiceDto: InvoiceDto): RequestConfig<InvoiceDto> {
        // val localVariableBody = invoiceDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = invoiceDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/reassign",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Remove an invoice of an user
     *
     * @param userId
     * @param serviceId
     * @param secretFKeys
     * @param requestBody
     * @return kotlin.collections.List<InvoiceDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun removeCodes(
        userId: String,
        serviceId: String,
        secretFKeys: String,
        requestBody: List<String>
    ): List<InvoiceDto> {
        val localVariableConfig = removeCodesRequestConfig(
            userId = userId,
            serviceId = serviceId,
            secretFKeys = secretFKeys,
            requestBody = requestBody
        )

        return request<List<String>, List<InvoiceDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation removeCodes
     *
     * @param userId
     * @param serviceId
     * @param secretFKeys
     * @param requestBody
     * @return RequestConfig
     */
    fun removeCodesRequestConfig(
        userId: String,
        serviceId: String,
        secretFKeys: String,
        requestBody: List<String>
    ): RequestConfig<List<String>> {
        // val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("secretFKeys", listOf(secretFKeys.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = requestBody

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/byauthor/{userId}/service/{serviceId}".replace(
                "{" + "userId" + "}",
                "${URLEncoder.encode(userId.toString(), Charsets.UTF_8)}"
            ).replace("{" + "serviceId" + "}", "${URLEncoder.encode(serviceId.toString(), Charsets.UTF_8)}"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update delegations in healthElements.
     * Keys must be delimited by coma
     * @param icureStubDto
     * @return kotlin.collections.List<IcureStubDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun setInvoicesDelegations(icureStubDto: List<IcureStubDto>): List<IcureStubDto> {
        val localVariableConfig = setInvoicesDelegationsRequestConfig(icureStubDto = icureStubDto)

        return request<List<IcureStubDto>, List<IcureStubDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation setInvoicesDelegations
     *
     * @param icureStubDto
     * @return RequestConfig
     */
    fun setInvoicesDelegationsRequestConfig(icureStubDto: List<IcureStubDto>): RequestConfig<List<IcureStubDto>> {
        // val localVariableBody = icureStubDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = icureStubDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/delegations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Gets all invoices for author at date
     *
     * @param invoiceId
     * @param scheme
     * @param forcedValue
     * @return InvoiceDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun validate(invoiceId: String, scheme: String, forcedValue: String): InvoiceDto {
        val localVariableConfig =
            validateRequestConfig(invoiceId = invoiceId, scheme = scheme, forcedValue = forcedValue)

        return request<Unit, InvoiceDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation validate
     *
     * @param invoiceId
     * @param scheme
     * @param forcedValue
     * @return RequestConfig
     */
    fun validateRequestConfig(
        invoiceId: String,
        scheme: String,
        forcedValue: String
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("scheme", listOf(scheme.toString()))
                put("forcedValue", listOf(forcedValue.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/invoice/validate/{invoiceId}".replace(
                "{" + "invoiceId" + "}",
                "${URLEncoder.encode(invoiceId.toString(), Charsets.UTF_8)}"
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
