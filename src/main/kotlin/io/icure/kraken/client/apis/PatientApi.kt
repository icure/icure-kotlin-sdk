/**
 * iCure Data Stack API Documentation
 *
 * The iCure Data Stack Application API is the native interface to iCure.
 *
 * The version of the OpenAPI document: v2
 *
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
package io.icure.kraken.client.apis

import io.icure.asyncjacksonhttpclient.net.web.WebClient
import io.icure.asyncjacksonhttpclient.netty.NettyWebClient
import io.icure.kraken.client.infrastructure.*
import org.taktik.icure.services.external.rest.v2.dto.embed.ContentDto
import org.taktik.icure.services.external.rest.v2.dto.DataOwnerRegistrationSuccessDto
import org.taktik.icure.services.external.rest.v2.dto.embed.DelegationDto
import io.icure.kraken.client.models.DocIdentifier
import org.taktik.icure.services.external.rest.v2.dto.IdWithRevDto
import org.taktik.icure.services.external.rest.v2.dto.ListOfIdsDto
import io.icure.kraken.client.models.PaginatedListPatientDto
import io.icure.kraken.client.models.PaginatedListString
import org.taktik.icure.services.external.rest.v2.dto.PatientDto
import io.icure.kraken.client.security.AuthProvider
import io.icure.kraken.client.security.NoAuthProvider
import kotlinx.coroutines.ExperimentalCoroutinesApi
import java.net.URLEncoder
import java.util.*
import javax.inject.Named

@Named
@ExperimentalStdlibApi
@ExperimentalCoroutinesApi
class PatientApi(
    basePath: String = defaultBasePath,
    webClient: WebClient = NettyWebClient(),
    authProvider: AuthProvider = NoAuthProvider()
) : ApiClient(basePath, webClient, authProvider) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("io.icure.kraken.client.baseUrl", "https://kraken.icure.dev")
        }
    }

    /**
     * Get count of patients for a specific HcParty or for the current HcParty
     * Returns the count of patients
     * @param hcPartyId Healthcare party id
     * @return ContentDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun countOfPatients(hcPartyId: String): ContentDto {
        val localVariableConfig = countOfPatientsRequestConfig(hcPartyId = hcPartyId)

        return request<Unit, ContentDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation countOfPatients
     *
     * @param hcPartyId Healthcare party id
     * @return RequestConfig
     */
    fun countOfPatientsRequestConfig(hcPartyId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/patient/hcParty/{hcPartyId}/count".replace(
                "{" + "hcPartyId" + "}",
                URLEncoder.encode(hcPartyId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create a patient
     * Name, last name, date of birth, and gender are required. After creation of the patient and obtaining the ID, you need to create an initial delegation.
     * @param patientDto
     * @return PatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createPatient(patientDto: PatientDto): PatientDto {
        val localVariableConfig = createPatientRequestConfig(patientDto = patientDto)

        return request<PatientDto, PatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation createPatient
     *
     * @param patientDto
     * @return RequestConfig
     */
    fun createPatientRequestConfig(patientDto: PatientDto): RequestConfig<PatientDto> {
        // val localVariableBody = patientDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = patientDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/patient",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create patients in bulk
     * Returns the id and _rev of created patients
     * @param patientDto
     * @return kotlin.collections.List<IdWithRevDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createPatients(patientDto: List<PatientDto>): List<IdWithRevDto> {
        val localVariableConfig = createPatientsRequestConfig(patientDto = patientDto)

        return request<List<PatientDto>, List<IdWithRevDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation createPatients
     *
     * @param patientDto
     * @return RequestConfig
     */
    fun createPatientsRequestConfig(patientDto: List<PatientDto>): RequestConfig<List<PatientDto>> {
        // val localVariableBody = patientDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = patientDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/patient/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete patients.
     * Response is an array containing the ID of deleted patient..
     * @param listOfIdsDto
     * @return kotlin.collections.List<DocIdentifier>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deletePatients(listOfIdsDto: ListOfIdsDto): List<DocIdentifier> {
        val localVariableConfig = deletePatientsRequestConfig(listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, List<DocIdentifier>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation deletePatients
     *
     * @param listOfIdsDto
     * @return RequestConfig
     */
    fun deletePatientsRequestConfig(listOfIdsDto: ListOfIdsDto): RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/patient/delete/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Filter patients for the current user (HcParty)
     * Returns a list of patients along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
     * @param filterChainPatient
     * @param startKey The start key for pagination, depends on the filters used (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @param skip Skip rows (optional)
     * @param sort Sort key (optional)
     * @param desc Descending (optional)
     * @return PaginatedListPatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filterPatientsBy(
        filterChainPatient: io.icure.kraken.client.models.filter.chain.FilterChain<PatientDto>,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?,
        skip: Int?,
        sort: String?,
        desc: Boolean?
    ): PaginatedListPatientDto {
        val localVariableConfig = filterPatientsByRequestConfig(
            filterChainPatient = filterChainPatient,
            startKey = startKey,
            startDocumentId = startDocumentId,
            limit = limit,
            skip = skip,
            sort = sort,
            desc = desc
        )

        return request<io.icure.kraken.client.models.filter.chain.FilterChain<PatientDto>, PaginatedListPatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation filterPatientsBy
     *
     * @param filterChainPatient
     * @param startKey The start key for pagination, depends on the filters used (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @param skip Skip rows (optional)
     * @param sort Sort key (optional)
     * @param desc Descending (optional)
     * @return RequestConfig
     */
    fun filterPatientsByRequestConfig(
        filterChainPatient: io.icure.kraken.client.models.filter.chain.FilterChain<PatientDto>,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?,
        skip: Int?,
        sort: String?,
        desc: Boolean?
    ): RequestConfig<io.icure.kraken.client.models.filter.chain.FilterChain<PatientDto>> {
        // val localVariableBody = filterChainPatient
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (skip != null) {
                    put("skip", listOf(skip.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (desc != null) {
                    put("desc", listOf(desc.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = filterChainPatient

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/patient/filter",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Find deleted patients
     * Returns a list of deleted patients, within the specified time period, if any.
     * @param startDate Filter deletions after this date (unix epoch), included (optional)
     * @param endDate Filter deletions before this date (unix epoch), included (optional)
     * @param desc Descending (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListPatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findDeletedPatients(
        startDate: Long?,
        endDate: Long?,
        desc: Boolean?,
        startDocumentId: String?,
        limit: Int?
    ): PaginatedListPatientDto {
        val localVariableConfig = findDeletedPatientsRequestConfig(
            startDate = startDate,
            endDate = endDate,
            desc = desc,
            startDocumentId = startDocumentId,
            limit = limit
        )

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation findDeletedPatients
     *
     * @param startDate Filter deletions after this date (unix epoch), included (optional)
     * @param endDate Filter deletions before this date (unix epoch), included (optional)
     * @param desc Descending (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @return RequestConfig
     */
    fun findDeletedPatientsRequestConfig(
        startDate: Long?,
        endDate: Long?,
        desc: Boolean?,
        startDocumentId: String?,
        limit: Int?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (desc != null) {
                    put("desc", listOf(desc.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/patient/deleted/byDate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Provides a paginated list of patients with duplicate name for an hecparty
     *
     * @param hcPartyId Healthcare party id
     * @param startKey The start key for pagination, depends on the filters used (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListPatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findDuplicatesByName(
        hcPartyId: String,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?
    ): PaginatedListPatientDto {
        val localVariableConfig = findDuplicatesByNameRequestConfig(
            hcPartyId = hcPartyId,
            startKey = startKey,
            startDocumentId = startDocumentId,
            limit = limit
        )

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation findDuplicatesByName
     *
     * @param hcPartyId Healthcare party id
     * @param startKey The start key for pagination, depends on the filters used (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @return RequestConfig
     */
    fun findDuplicatesByNameRequestConfig(
        hcPartyId: String,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId))
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/patient/duplicates/name",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Provides a paginated list of patients with duplicate ssin for an hecparty
     *
     * @param hcPartyId Healthcare party id
     * @param startKey The start key for pagination, depends on the filters used (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListPatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findDuplicatesBySsin(
        hcPartyId: String,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?
    ): PaginatedListPatientDto {
        val localVariableConfig = findDuplicatesBySsinRequestConfig(
            hcPartyId = hcPartyId,
            startKey = startKey,
            startDocumentId = startDocumentId,
            limit = limit
        )

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation findDuplicatesBySsin
     *
     * @param hcPartyId Healthcare party id
     * @param startKey The start key for pagination, depends on the filters used (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @return RequestConfig
     */
    fun findDuplicatesBySsinRequestConfig(
        hcPartyId: String,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId))
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/patient/duplicates/ssin",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Paginated List of Patients sorted by Access logs descending
     *
     * @param userId A User ID
     * @param accessType The type of access (COMPUTER or USER) (optional)
     * @param startDate The start search epoch (optional)
     * @param startKey The start key for pagination (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional, default to 1000)
     * @return PaginatedListPatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findPatientsByAccessLogUserAfterDate(
        userId: String,
        accessType: String?,
        startDate: Long?,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?
    ): PaginatedListPatientDto {
        val localVariableConfig = findPatientsByAccessLogUserAfterDateRequestConfig(
            userId = userId,
            accessType = accessType,
            startDate = startDate,
            startKey = startKey,
            startDocumentId = startDocumentId,
            limit = limit
        )

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation findPatientsByAccessLogUserAfterDate
     *
     * @param userId A User ID
     * @param accessType The type of access (COMPUTER or USER) (optional)
     * @param startDate The start search epoch (optional)
     * @param startKey The start key for pagination (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional, default to 1000)
     * @return RequestConfig
     */
    fun findPatientsByAccessLogUserAfterDateRequestConfig(
        userId: String,
        accessType: String?,
        startDate: Long?,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (accessType != null) {
                    put("accessType", listOf(accessType.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/patient/byAccess/{userId}".replace(
                "{" + "userId" + "}",
                URLEncoder.encode(userId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List patients for a specific HcParty
     * Returns a list of patients along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
     * @param hcPartyId Healthcare party id (optional)
     * @param sortField Optional value for sorting results by a given field (&#39;name&#39;, &#39;ssin&#39;, &#39;dateOfBirth&#39;). Specifying this deactivates filtering (optional)
     * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @param sortDirection Optional value for providing a sorting direction (&#39;asc&#39;, &#39;desc&#39;). Set to &#39;asc&#39; by default. (optional, default to "asc")
     * @return PaginatedListPatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findPatientsByHealthcareParty(
        hcPartyId: String?,
        sortField: String?,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?,
        sortDirection: String?
    ): PaginatedListPatientDto {
        val localVariableConfig = findPatientsByHealthcarePartyRequestConfig(
            hcPartyId = hcPartyId,
            sortField = sortField,
            startKey = startKey,
            startDocumentId = startDocumentId,
            limit = limit,
            sortDirection = sortDirection
        )

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation findPatientsByHealthcareParty
     *
     * @param hcPartyId Healthcare party id (optional)
     * @param sortField Optional value for sorting results by a given field (&#39;name&#39;, &#39;ssin&#39;, &#39;dateOfBirth&#39;). Specifying this deactivates filtering (optional)
     * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @param sortDirection Optional value for providing a sorting direction (&#39;asc&#39;, &#39;desc&#39;). Set to &#39;asc&#39; by default. (optional, default to "asc")
     * @return RequestConfig
     */
    fun findPatientsByHealthcarePartyRequestConfig(
        hcPartyId: String?,
        sortField: String?,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?,
        sortDirection: String?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (hcPartyId != null) {
                    put("hcPartyId", listOf(hcPartyId.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sortDirection != null) {
                    put("sortDirection", listOf(sortDirection.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/patient",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Find patients for the current user (HcParty)
     * Returns a list of patients along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
     * @param healthcarePartyId HealthcareParty Id, if unset will user user&#39;s hcpId (optional)
     * @param filterValue Optional value for filtering results (optional)
     * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @param sortDirection Optional value for providing a sorting direction (&#39;asc&#39;, &#39;desc&#39;). Set to &#39;asc&#39; by default. (optional, default to "asc")
     * @return PaginatedListPatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findPatientsByNameBirthSsinAuto(
        healthcarePartyId: String?,
        filterValue: String?,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?,
        sortDirection: String?
    ): PaginatedListPatientDto {
        val localVariableConfig = findPatientsByNameBirthSsinAutoRequestConfig(
            healthcarePartyId = healthcarePartyId,
            filterValue = filterValue,
            startKey = startKey,
            startDocumentId = startDocumentId,
            limit = limit,
            sortDirection = sortDirection
        )

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation findPatientsByNameBirthSsinAuto
     *
     * @param healthcarePartyId HealthcareParty Id, if unset will user user&#39;s hcpId (optional)
     * @param filterValue Optional value for filtering results (optional)
     * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @param sortDirection Optional value for providing a sorting direction (&#39;asc&#39;, &#39;desc&#39;). Set to &#39;asc&#39; by default. (optional, default to "asc")
     * @return RequestConfig
     */
    fun findPatientsByNameBirthSsinAutoRequestConfig(
        healthcarePartyId: String?,
        filterValue: String?,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?,
        sortDirection: String?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (healthcarePartyId != null) {
                    put("healthcarePartyId", listOf(healthcarePartyId.toString()))
                }
                if (filterValue != null) {
                    put("filterValue", listOf(filterValue.toString()))
                }
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sortDirection != null) {
                    put("sortDirection", listOf(sortDirection.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/patient/byNameBirthSsinAuto",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List patients by pages for a specific HcParty
     * Returns a list of patients along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
     * @param hcPartyId Healthcare party id
     * @param startKey The page first id (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Page size (optional)
     * @return PaginatedListString
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findPatientsIdsByHealthcareParty(
        hcPartyId: String,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?
    ): PaginatedListString {
        val localVariableConfig = findPatientsIdsByHealthcarePartyRequestConfig(
            hcPartyId = hcPartyId,
            startKey = startKey,
            startDocumentId = startDocumentId,
            limit = limit
        )

        return request<Unit, PaginatedListString>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation findPatientsIdsByHealthcareParty
     *
     * @param hcPartyId Healthcare party id
     * @param startKey The page first id (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Page size (optional)
     * @return RequestConfig
     */
    fun findPatientsIdsByHealthcarePartyRequestConfig(
        hcPartyId: String,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId))
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/patient/byHcPartyId",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List patients that have been modified after the provided date
     * Returns a list of patients that have been modified after the provided date
     * @param date
     * @param startKey The start key for pagination the date of the first element of the new page (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListPatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findPatientsModifiedAfter(
        date: Long,
        startKey: Long?,
        startDocumentId: String?,
        limit: Int?
    ): PaginatedListPatientDto {
        val localVariableConfig = findPatientsModifiedAfterRequestConfig(
            date = date,
            startKey = startKey,
            startDocumentId = startDocumentId,
            limit = limit
        )

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation findPatientsModifiedAfter
     *
     * @param date
     * @param startKey The start key for pagination the date of the first element of the new page (optional)
     * @param startDocumentId A patient document ID (optional)
     * @param limit Number of rows (optional)
     * @return RequestConfig
     */
    fun findPatientsModifiedAfterRequestConfig(
        date: Long,
        startKey: Long?,
        startDocumentId: String?,
        limit: Int?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/patient/modifiedAfter/{date}".replace(
                "{" + "date" + "}",
                URLEncoder.encode(date.toString(), Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Filter patients for the current user (HcParty)
     * Returns a list of patients
     * @param firstName The first name (optional)
     * @param lastName The last name (optional)
     * @param dateOfBirth The date of birth (optional)
     * @return kotlin.collections.List<PatientDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun fuzzySearch(
        firstName: String?,
        lastName: String?,
        dateOfBirth: Int?
    ): List<PatientDto> {
        val localVariableConfig =
            fuzzySearchRequestConfig(firstName = firstName, lastName = lastName, dateOfBirth = dateOfBirth)

        return request<Unit, List<PatientDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation fuzzySearch
     *
     * @param firstName The first name (optional)
     * @param lastName The last name (optional)
     * @param dateOfBirth The date of birth (optional)
     * @return RequestConfig
     */
    fun fuzzySearchRequestConfig(
        firstName: String?,
        lastName: String?,
        dateOfBirth: Int?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (firstName != null) {
                    put("firstName", listOf(firstName.toString()))
                }
                if (lastName != null) {
                    put("lastName", listOf(lastName.toString()))
                }
                if (dateOfBirth != null) {
                    put("dateOfBirth", listOf(dateOfBirth.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/patient/fuzzy",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get patient
     * It gets patient administrative data.
     * @param patientId
     * @return PatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getPatient(patientId: String): PatientDto {
        val localVariableConfig = getPatientRequestConfig(patientId = patientId)

        return request<Unit, PatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getPatient
     *
     * @param patientId
     * @return RequestConfig
     */
    fun getPatientRequestConfig(patientId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/patient/{patientId}".replace(
                "{" + "patientId" + "}",
                URLEncoder.encode(patientId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get the HcParty encrypted AES keys indexed by owner.
     * (key, value) of the map is as follows: (ID of the owner of the encrypted AES key, encrypted AES keys)
     * @param patientId
     * @return kotlin.collections.Map<kotlin.String, kotlin.collections.Map<kotlin.String, kotlin.collections.Map<kotlin.String, kotlin.String>>>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getPatientAesExchangeKeysForDelegate(patientId: String): Map<String, Map<String, Map<String, String>>> {
        val localVariableConfig = getPatientAesExchangeKeysForDelegateRequestConfig(patientId = patientId)

        return request<Unit, Map<String, Map<String, Map<String, String>>>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getPatientAesExchangeKeysForDelegate
     *
     * @param patientId
     * @return RequestConfig
     */
    fun getPatientAesExchangeKeysForDelegateRequestConfig(patientId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/patient/{patientId}/aesExchangeKeys".replace(
                "{" + "patientId" + "}",
                URLEncoder.encode(patientId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get the patient having the provided externalId
     *
     * @param externalId A external ID
     * @return PatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getPatientByExternalId(externalId: String): PatientDto {
        val localVariableConfig = getPatientByExternalIdRequestConfig(externalId = externalId)

        return request<Unit, PatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getPatientByExternalId
     *
     * @param externalId A external ID
     * @return RequestConfig
     */
    fun getPatientByExternalIdRequestConfig(externalId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/patient/byExternalId/{externalId}".replace(
                "{" + "externalId" + "}",
                URLEncoder.encode(externalId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get patient by identifier
     * It gets patient administrative data based on the identifier (root &amp; extension) parameters.
     * @param hcPartyId
     * @param id
     * @param system  (optional)
     * @return PatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getPatientByHealthcarepartyAndIdentifier(
        hcPartyId: String,
        id: String,
        system: String?
    ): PatientDto {
        val localVariableConfig =
            getPatientByHealthcarepartyAndIdentifierRequestConfig(hcPartyId = hcPartyId, id = id, system = system)

        return request<Unit, PatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getPatientByHealthcarepartyAndIdentifier
     *
     * @param hcPartyId
     * @param id
     * @param system  (optional)
     * @return RequestConfig
     */
    fun getPatientByHealthcarepartyAndIdentifierRequestConfig(
        hcPartyId: String,
        id: String,
        system: String?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (system != null) {
                    put("system", listOf(system.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/patient/{hcPartyId}/{id}".replace(
                "{" + "hcPartyId" + "}",
                URLEncoder.encode(hcPartyId, Charsets.UTF_8)
            ).replace("{" + "id" + "}", URLEncoder.encode(id, Charsets.UTF_8)),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get patients by id
     * It gets patient administrative data.
     * @param listOfIdsDto
     * @return kotlin.collections.List<PatientDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getPatients(listOfIdsDto: ListOfIdsDto): List<PatientDto> {
        val localVariableConfig = getPatientsRequestConfig(listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, List<PatientDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getPatients
     *
     * @param listOfIdsDto
     * @return RequestConfig
     */
    fun getPatientsRequestConfig(listOfIdsDto: ListOfIdsDto): RequestConfig<ListOfIdsDto> {
        // val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = listOfIdsDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/patient/byIds",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Find deleted patients
     * Returns a list of deleted patients, by name and/or firstname prefix, if any.
     * @param firstName First name prefix (optional)
     * @param lastName Last name prefix (optional)
     * @return kotlin.collections.List<PatientDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listDeletedPatientsByName(
        firstName: String?,
        lastName: String?
    ): List<PatientDto> {
        val localVariableConfig = listDeletedPatientsByNameRequestConfig(firstName = firstName, lastName = lastName)

        return request<Unit, List<PatientDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listDeletedPatientsByName
     *
     * @param firstName First name prefix (optional)
     * @param lastName Last name prefix (optional)
     * @return RequestConfig
     */
    fun listDeletedPatientsByNameRequestConfig(
        firstName: String?,
        lastName: String?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (firstName != null) {
                    put("firstName", listOf(firstName.toString()))
                }
                if (lastName != null) {
                    put("lastName", listOf(lastName.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/patient/deleted/by_name",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List patients that have been merged towards another patient
     * Returns a list of patients that have been merged after the provided date
     * @param date
     * @return kotlin.collections.List<PatientDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listOfMergesAfter(date: Long): List<PatientDto> {
        val localVariableConfig = listOfMergesAfterRequestConfig(date = date)

        return request<Unit, List<PatientDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listOfMergesAfter
     *
     * @param date
     * @return RequestConfig
     */
    fun listOfMergesAfterRequestConfig(date: Long): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/patient/merges/{date}".replace(
                "{" + "date" + "}",
                URLEncoder.encode(date.toString(), Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get ids of patients matching the provided filter for the current user (HcParty)
     *
     * @param abstractFilterDtoPatient
     * @return kotlin.collections.List<kotlin.String>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun matchPatientsBy(abstractFilterDtoPatient: io.icure.kraken.client.models.filter.AbstractFilterDto<PatientDto>): List<String> {
        val localVariableConfig = matchPatientsByRequestConfig(abstractFilterDtoPatient = abstractFilterDtoPatient)

        return request<io.icure.kraken.client.models.filter.AbstractFilterDto<PatientDto>, List<String>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation matchPatientsBy
     *
     * @param abstractFilterDtoPatient
     * @return RequestConfig
     */
    fun matchPatientsByRequestConfig(abstractFilterDtoPatient: io.icure.kraken.client.models.filter.AbstractFilterDto<PatientDto>): RequestConfig<io.icure.kraken.client.models.filter.AbstractFilterDto<PatientDto>> {
        // val localVariableBody = abstractFilterDtoPatient
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = abstractFilterDtoPatient

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/patient/match",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Merge a series of patients into another patient
     *
     * @param toId
     * @param fromIds
     * @return PatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun mergeInto(toId: String, fromIds: String): PatientDto {
        val localVariableConfig = mergeIntoRequestConfig(toId = toId, fromIds = fromIds)

        return request<Unit, PatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation mergeInto
     *
     * @param toId
     * @param fromIds
     * @return RequestConfig
     */
    fun mergeIntoRequestConfig(toId: String, fromIds: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/patient/mergeInto/{toId}/from/{fromIds}".replace(
                "{" + "toId" + "}",
                URLEncoder.encode(toId, Charsets.UTF_8)
            ).replace("{" + "fromIds" + "}", URLEncoder.encode(fromIds, Charsets.UTF_8)),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Modify a patient
     * No particular return value. It&#39;s just a message.
     * @param patientDto
     * @return PatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyPatient(patientDto: PatientDto): PatientDto {
        val localVariableConfig = modifyPatientRequestConfig(patientDto = patientDto)

        return request<PatientDto, PatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation modifyPatient
     *
     * @param patientDto
     * @return RequestConfig
     */
    fun modifyPatientRequestConfig(patientDto: PatientDto): RequestConfig<PatientDto> {
        // val localVariableBody = patientDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = patientDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/patient",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Set a patient referral doctor
     *
     * @param patientId
     * @param referralId The referal id. Accepts &#39;none&#39; for referral removal.
     * @param start Optional value for start of referral (optional)
     * @param end Optional value for end of referral (optional)
     * @return PatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyPatientReferral(
        patientId: String,
        referralId: String,
        start: Long?,
        end: Long?
    ): PatientDto {
        val localVariableConfig =
            modifyPatientReferralRequestConfig(patientId = patientId, referralId = referralId, start = start, end = end)

        return request<Unit, PatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation modifyPatientReferral
     *
     * @param patientId
     * @param referralId The referal id. Accepts &#39;none&#39; for referral removal.
     * @param start Optional value for start of referral (optional)
     * @param end Optional value for end of referral (optional)
     * @return RequestConfig
     */
    fun modifyPatientReferralRequestConfig(
        patientId: String,
        referralId: String,
        start: Long?,
        end: Long?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (end != null) {
                    put("end", listOf(end.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/patient/{patientId}/referral/{referralId}".replace(
                "{" + "patientId" + "}",
                URLEncoder.encode(patientId, Charsets.UTF_8)
            ).replace("{" + "referralId" + "}", URLEncoder.encode(referralId, Charsets.UTF_8)),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Modify patients in bulk
     * Returns the id and _rev of modified patients
     * @param patientDto
     * @return kotlin.collections.List<IdWithRevDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyPatients(patientDto: List<PatientDto>): List<IdWithRevDto> {
        val localVariableConfig = modifyPatientsRequestConfig(patientDto = patientDto)

        return request<List<PatientDto>, List<IdWithRevDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation modifyPatients
     *
     * @param patientDto
     * @return RequestConfig
     */
    fun modifyPatientsRequestConfig(patientDto: List<PatientDto>): RequestConfig<List<PatientDto>> {
        // val localVariableBody = patientDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = patientDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/patient/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delegates a patients to a healthcare party
     * It delegates a patient to a healthcare party (By current healthcare party). A modified patient with new delegation gets returned.
     * @param patientId
     * @param delegationDto
     * @return PatientDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun newPatientDelegations(
        patientId: String,
        delegationDto: List<DelegationDto>
    ): PatientDto {
        val localVariableConfig =
            newPatientDelegationsRequestConfig(patientId = patientId, delegationDto = delegationDto)

        return request<List<DelegationDto>, PatientDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation newPatientDelegations
     *
     * @param patientId
     * @param delegationDto
     * @return RequestConfig
     */
    fun newPatientDelegationsRequestConfig(
        patientId: String,
        delegationDto: List<DelegationDto>
    ): RequestConfig<List<DelegationDto>> {
        // val localVariableBody = delegationDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = delegationDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/patient/{patientId}/delegate".replace(
                "{" + "patientId" + "}",
                URLEncoder.encode(patientId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Register a patient
     * Register a new patient into the system
     * @param hcPartyId
     * @param groupId
     * @param patientDto
     * @param token  (optional)
     * @param useShortToken  (optional)
     * @return DataOwnerRegistrationSuccessDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun registerPatient(
        hcPartyId: String,
        groupId: String,
        patientDto: PatientDto,
        token: String?,
        useShortToken: Boolean?
    ): DataOwnerRegistrationSuccessDto {
        val localVariableConfig = registerPatientRequestConfig(
            hcPartyId = hcPartyId,
            groupId = groupId,
            patientDto = patientDto,
            token = token,
            useShortToken = useShortToken
        )

        return request<PatientDto, DataOwnerRegistrationSuccessDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation registerPatient
     *
     * @param hcPartyId
     * @param groupId
     * @param patientDto
     * @param token  (optional)
     * @param useShortToken  (optional)
     * @return RequestConfig
     */
    fun registerPatientRequestConfig(
        hcPartyId: String,
        groupId: String,
        patientDto: PatientDto,
        token: String?,
        useShortToken: Boolean?
    ): RequestConfig<PatientDto> {
        // val localVariableBody = patientDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (useShortToken != null) {
                    put("useShortToken", listOf(useShortToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = patientDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/patient/register/forHcp/{hcPartyId}/inGroup/{groupId}".replace(
                "{" + "hcPartyId" + "}",
                URLEncoder.encode(hcPartyId, Charsets.UTF_8)
            ).replace("{" + "groupId" + "}", URLEncoder.encode(groupId, Charsets.UTF_8)),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Register a patient
     * Register a new patient into the system without setting up an auto-delegation for the HCP
     * @param groupId
     * @param patientDto
     * @param token  (optional)
     * @param useShortToken  (optional)
     * @return DataOwnerRegistrationSuccessDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun registerPatientInGroup(
        groupId: String,
        patientDto: PatientDto,
        token: String?,
        useShortToken: Boolean?
    ): DataOwnerRegistrationSuccessDto {
        val localVariableConfig = registerPatientInGroupRequestConfig(
            groupId = groupId,
            patientDto = patientDto,
            token = token,
            useShortToken = useShortToken
        )

        return request<PatientDto, DataOwnerRegistrationSuccessDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation registerPatient
     *
     * @param groupId
     * @param patientDto
     * @param token  (optional)
     * @param useShortToken  (optional)
     * @return RequestConfig
     */
    fun registerPatientInGroupRequestConfig(
        groupId: String,
        patientDto: PatientDto,
        token: String?,
        useShortToken: Boolean?
    ): RequestConfig<PatientDto> {
        // val localVariableBody = patientDto
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (token != null) {
                    put("token", listOf(token.toString()))
                }
                if (useShortToken != null) {
                    put("useShortToken", listOf(useShortToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = patientDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/patient/register/inGroup/{groupId}".replace(
                "{" + "groupId" + "}",
                URLEncoder.encode(groupId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * undelete previously deleted patients
     * Response is an array containing the ID of undeleted patient..
     * @param patientIds
     * @return kotlin.collections.List<DocIdentifier>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun undeletePatient(patientIds: String): List<DocIdentifier> {
        val localVariableConfig = undeletePatientRequestConfig(patientIds = patientIds)

        return request<Unit, List<DocIdentifier>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation undeletePatient
     *
     * @param patientIds
     * @return RequestConfig
     */
    fun undeletePatientRequestConfig(patientIds: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/patient/undelete/{patientIds}".replace(
                "{" + "patientIds" + "}",
                URLEncoder.encode(patientIds, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
