/**
 * iCure Data Stack API Documentation
 *
 * The iCure Data Stack Application API is the native interface to iCure. This version is obsolete, please use v2.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
package io.icure.kraken.client.apis

import io.icure.asyncjacksonhttpclient.net.web.WebClient
import io.icure.asyncjacksonhttpclient.netty.NettyWebClient

import io.icure.kraken.client.models.ContentDto
import io.icure.kraken.client.models.DelegationDto
import io.icure.kraken.client.models.DocIdentifier
import io.icure.kraken.client.models.FilterChainPatient
import io.icure.kraken.client.models.IdWithRevDto
import io.icure.kraken.client.models.ListOfIdsDto
import io.icure.kraken.client.models.PaginatedListPatientDto
import io.icure.kraken.client.models.PaginatedListString
import io.icure.kraken.client.models.PatientDto
import io.icure.kraken.client.models.PatientRegistrationSuccessDto

import kotlinx.coroutines.ExperimentalCoroutinesApi

import io.icure.kraken.client.infrastructure.ApiClient
import io.icure.kraken.client.infrastructure.ClientException
import io.icure.kraken.client.infrastructure.ServerException
import io.icure.kraken.client.infrastructure.MultiValueMap
import io.icure.kraken.client.infrastructure.RequestConfig
import io.icure.kraken.client.infrastructure.RequestMethod
import javax.inject.Named

@Named
@ExperimentalStdlibApi
@ExperimentalCoroutinesApi
class PatientApi(basePath: kotlin.String = defaultBasePath, webClient: WebClient = NettyWebClient(), authHeader: String? = null) : ApiClient(basePath, webClient, authHeader) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("io.icure.kraken.client.baseUrl", "https://kraken.icure.dev")
        }
    }

    /**
    * Create patients in bulk
    * Returns the id and _rev of created patients
    * @param patientDto  
    * @return kotlin.collections.List<IdWithRevDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun bulkCreatePatients(patientDto: kotlin.collections.List<PatientDto>) : kotlin.collections.List<IdWithRevDto>?  {
        val localVariableConfig = bulkCreatePatientsRequestConfig(patientDto = patientDto)

        return request<kotlin.collections.List<PatientDto>, kotlin.collections.List<IdWithRevDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation bulkCreatePatients
    *
    * @param patientDto  
    * @return RequestConfig
    */
    fun bulkCreatePatientsRequestConfig(patientDto: kotlin.collections.List<PatientDto>) : RequestConfig<kotlin.collections.List<PatientDto>> {
        val localVariableBody = patientDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/patient/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create patients in bulk
    * Returns the id and _rev of created patients
    * @param patientDto  
    * @return kotlin.collections.List<IdWithRevDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun bulkCreatePatients1(patientDto: kotlin.collections.List<PatientDto>) : kotlin.collections.List<IdWithRevDto>?  {
        val localVariableConfig = bulkCreatePatients1RequestConfig(patientDto = patientDto)

        return request<kotlin.collections.List<PatientDto>, kotlin.collections.List<IdWithRevDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation bulkCreatePatients1
    *
    * @param patientDto  
    * @return RequestConfig
    */
    fun bulkCreatePatients1RequestConfig(patientDto: kotlin.collections.List<PatientDto>) : RequestConfig<kotlin.collections.List<PatientDto>> {
        val localVariableBody = patientDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/patient/bulk",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Modify patients in bulk
    * Returns the id and _rev of modified patients
    * @param patientDto  
    * @return kotlin.collections.List<IdWithRevDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun bulkUpdatePatients(patientDto: kotlin.collections.List<PatientDto>) : kotlin.collections.List<IdWithRevDto>?  {
        val localVariableConfig = bulkUpdatePatientsRequestConfig(patientDto = patientDto)

        return request<kotlin.collections.List<PatientDto>, kotlin.collections.List<IdWithRevDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation bulkUpdatePatients
    *
    * @param patientDto  
    * @return RequestConfig
    */
    fun bulkUpdatePatientsRequestConfig(patientDto: kotlin.collections.List<PatientDto>) : RequestConfig<kotlin.collections.List<PatientDto>> {
        val localVariableBody = patientDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v1/patient/batch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Modify patients in bulk
    * Returns the id and _rev of modified patients
    * @param patientDto  
    * @return kotlin.collections.List<IdWithRevDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun bulkUpdatePatients1(patientDto: kotlin.collections.List<PatientDto>) : kotlin.collections.List<IdWithRevDto>?  {
        val localVariableConfig = bulkUpdatePatients1RequestConfig(patientDto = patientDto)

        return request<kotlin.collections.List<PatientDto>, kotlin.collections.List<IdWithRevDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation bulkUpdatePatients1
    *
    * @param patientDto  
    * @return RequestConfig
    */
    fun bulkUpdatePatients1RequestConfig(patientDto: kotlin.collections.List<PatientDto>) : RequestConfig<kotlin.collections.List<PatientDto>> {
        val localVariableBody = patientDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v1/patient/bulk",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get count of patients for a specific HcParty or for the current HcParty 
    * Returns the count of patients
    * @param hcPartyId Healthcare party id 
    * @return ContentDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun countOfPatients(hcPartyId: kotlin.String) : ContentDto?  {
        val localVariableConfig = countOfPatientsRequestConfig(hcPartyId = hcPartyId)

        return request<Unit, ContentDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation countOfPatients
    *
    * @param hcPartyId Healthcare party id 
    * @return RequestConfig
    */
    fun countOfPatientsRequestConfig(hcPartyId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/hcParty/{hcPartyId}/count".replace("{"+"hcPartyId"+"}", "$hcPartyId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Create a patient
    * Name, last name, date of birth, and gender are required. After creation of the patient and obtaining the ID, you need to create an initial delegation.
    * @param patientDto  
    * @return PatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createPatient(patientDto: PatientDto) : PatientDto?  {
        val localVariableConfig = createPatientRequestConfig(patientDto = patientDto)

        return request<PatientDto, PatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation createPatient
    *
    * @param patientDto  
    * @return RequestConfig
    */
    fun createPatientRequestConfig(patientDto: PatientDto) : RequestConfig<PatientDto> {
        val localVariableBody = patientDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/patient",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delete patients.
    * Response is an array containing the ID of deleted patient..
    * @param patientIds  
    * @return kotlin.collections.List<DocIdentifier>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deletePatient(patientIds: kotlin.String) : kotlin.collections.List<DocIdentifier>?  {
        val localVariableConfig = deletePatientRequestConfig(patientIds = patientIds)

        return request<Unit, kotlin.collections.List<DocIdentifier>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation deletePatient
    *
    * @param patientIds  
    * @return RequestConfig
    */
    fun deletePatientRequestConfig(patientIds: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/rest/v1/patient/{patientIds}".replace("{"+"patientIds"+"}", "$patientIds"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Filter patients for the current user (HcParty) 
    * Returns a list of patients along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
    * @param filterChainPatient  
    * @param startKey The start key for pagination, depends on the filters used (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @param skip Skip rows (optional)
    * @param sort Sort key (optional)
    * @param desc Descending (optional)
    * @return PaginatedListPatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filterPatientsBy(filterChainPatient: FilterChainPatient, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?, skip: kotlin.Int?, sort: kotlin.String?, desc: kotlin.Boolean?) : PaginatedListPatientDto?  {
        val localVariableConfig = filterPatientsByRequestConfig(filterChainPatient = filterChainPatient, startKey = startKey, startDocumentId = startDocumentId, limit = limit, skip = skip, sort = sort, desc = desc)

        return request<FilterChainPatient, PaginatedListPatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation filterPatientsBy
    *
    * @param filterChainPatient  
    * @param startKey The start key for pagination, depends on the filters used (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @param skip Skip rows (optional)
    * @param sort Sort key (optional)
    * @param desc Descending (optional)
    * @return RequestConfig
    */
    fun filterPatientsByRequestConfig(filterChainPatient: FilterChainPatient, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?, skip: kotlin.Int?, sort: kotlin.String?, desc: kotlin.Boolean?) : RequestConfig<FilterChainPatient> {
        val localVariableBody = filterChainPatient
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (skip != null) {
                    put("skip", listOf(skip.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (desc != null) {
                    put("desc", listOf(desc.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/patient/filter",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get Paginated List of Patients sorted by Access logs descending
    * 
    * @param userId A User ID 
    * @param accessType The type of access (COMPUTER or USER) (optional)
    * @param startDate The start search epoch (optional)
    * @param startKey The start key for pagination (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional, default to 1000)
    * @return PaginatedListPatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findByAccessLogUserAfterDate(userId: kotlin.String, accessType: kotlin.String?, startDate: kotlin.Long?, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?) : PaginatedListPatientDto?  {
        val localVariableConfig = findByAccessLogUserAfterDateRequestConfig(userId = userId, accessType = accessType, startDate = startDate, startKey = startKey, startDocumentId = startDocumentId, limit = limit)

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findByAccessLogUserAfterDate
    *
    * @param userId A User ID 
    * @param accessType The type of access (COMPUTER or USER) (optional)
    * @param startDate The start search epoch (optional)
    * @param startKey The start key for pagination (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional, default to 1000)
    * @return RequestConfig
    */
    fun findByAccessLogUserAfterDateRequestConfig(userId: kotlin.String, accessType: kotlin.String?, startDate: kotlin.Long?, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (accessType != null) {
                    put("accessType", listOf(accessType.toString()))
                }
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/byAccess/{userId}".replace("{"+"userId"+"}", "$userId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get the patient having the provided externalId
    * 
    * @param externalId A external ID 
    * @return PatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findByExternalId(externalId: kotlin.String) : PatientDto?  {
        val localVariableConfig = findByExternalIdRequestConfig(externalId = externalId)

        return request<Unit, PatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findByExternalId
    *
    * @param externalId A external ID 
    * @return RequestConfig
    */
    fun findByExternalIdRequestConfig(externalId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/byExternalId/{externalId}".replace("{"+"externalId"+"}", "$externalId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Find patients for the current user (HcParty) 
    * Returns a list of patients along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
    * @param healthcarePartyId HealthcareParty Id. If not set, will use user&#39;s hcpId (optional)
    * @param filterValue Optional value for filtering results (optional)
    * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @param sortDirection Optional value for providing a sorting direction (&#39;asc&#39;, &#39;desc&#39;). Set to &#39;asc&#39; by default. (optional, default to "asc")
    * @return PaginatedListPatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findByNameBirthSsinAuto(healthcarePartyId: kotlin.String?, filterValue: kotlin.String?, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?, sortDirection: kotlin.String?) : PaginatedListPatientDto?  {
        val localVariableConfig = findByNameBirthSsinAutoRequestConfig(healthcarePartyId = healthcarePartyId, filterValue = filterValue, startKey = startKey, startDocumentId = startDocumentId, limit = limit, sortDirection = sortDirection)

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findByNameBirthSsinAuto
    *
    * @param healthcarePartyId HealthcareParty Id. If not set, will use user&#39;s hcpId (optional)
    * @param filterValue Optional value for filtering results (optional)
    * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @param sortDirection Optional value for providing a sorting direction (&#39;asc&#39;, &#39;desc&#39;). Set to &#39;asc&#39; by default. (optional, default to "asc")
    * @return RequestConfig
    */
    fun findByNameBirthSsinAutoRequestConfig(healthcarePartyId: kotlin.String?, filterValue: kotlin.String?, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?, sortDirection: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (healthcarePartyId != null) {
                    put("healthcarePartyId", listOf(healthcarePartyId.toString()))
                }
                if (filterValue != null) {
                    put("filterValue", listOf(filterValue.toString()))
                }
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sortDirection != null) {
                    put("sortDirection", listOf(sortDirection.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/byNameBirthSsinAuto",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Provides a paginated list of patients with duplicate name for an hecparty
    * 
    * @param hcPartyId Healthcare party id 
    * @param startKey The start key for pagination, depends on the filters used (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @return PaginatedListPatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findDuplicatesByName(hcPartyId: kotlin.String, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?) : PaginatedListPatientDto?  {
        val localVariableConfig = findDuplicatesByNameRequestConfig(hcPartyId = hcPartyId, startKey = startKey, startDocumentId = startDocumentId, limit = limit)

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findDuplicatesByName
    *
    * @param hcPartyId Healthcare party id 
    * @param startKey The start key for pagination, depends on the filters used (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @return RequestConfig
    */
    fun findDuplicatesByNameRequestConfig(hcPartyId: kotlin.String, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId.toString()))
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/patient/duplicates/name",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Provides a paginated list of patients with duplicate ssin for an hecparty
    * 
    * @param hcPartyId Healthcare party id 
    * @param startKey The start key for pagination, depends on the filters used (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @return PaginatedListPatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findDuplicatesBySsin(hcPartyId: kotlin.String, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?) : PaginatedListPatientDto?  {
        val localVariableConfig = findDuplicatesBySsinRequestConfig(hcPartyId = hcPartyId, startKey = startKey, startDocumentId = startDocumentId, limit = limit)

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation findDuplicatesBySsin
    *
    * @param hcPartyId Healthcare party id 
    * @param startKey The start key for pagination, depends on the filters used (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @return RequestConfig
    */
    fun findDuplicatesBySsinRequestConfig(hcPartyId: kotlin.String, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId.toString()))
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/patient/duplicates/ssin",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Filter patients for the current user (HcParty) 
    * Returns a list of patients
    * @param firstName The first name (optional)
    * @param lastName The last name (optional)
    * @param dateOfBirth The date of birth (optional)
    * @return kotlin.collections.List<PatientDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun fuzzySearch(firstName: kotlin.String?, lastName: kotlin.String?, dateOfBirth: kotlin.Int?) : kotlin.collections.List<PatientDto>?  {
        val localVariableConfig = fuzzySearchRequestConfig(firstName = firstName, lastName = lastName, dateOfBirth = dateOfBirth)

        return request<Unit, kotlin.collections.List<PatientDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation fuzzySearch
    *
    * @param firstName The first name (optional)
    * @param lastName The last name (optional)
    * @param dateOfBirth The date of birth (optional)
    * @return RequestConfig
    */
    fun fuzzySearchRequestConfig(firstName: kotlin.String?, lastName: kotlin.String?, dateOfBirth: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (firstName != null) {
                    put("firstName", listOf(firstName.toString()))
                }
                if (lastName != null) {
                    put("lastName", listOf(lastName.toString()))
                }
                if (dateOfBirth != null) {
                    put("dateOfBirth", listOf(dateOfBirth.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/fuzzy",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get patient
    * It gets patient administrative data.
    * @param patientId  
    * @return PatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getPatient(patientId: kotlin.String) : PatientDto?  {
        val localVariableConfig = getPatientRequestConfig(patientId = patientId)

        return request<Unit, PatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getPatient
    *
    * @param patientId  
    * @return RequestConfig
    */
    fun getPatientRequestConfig(patientId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/{patientId}".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get patient by identifier
    * It gets patient administrative data based on the identifier (root &amp; extension) parameters.
    * @param hcPartyId  
    * @param id  
    * @param system  (optional)
    * @return PatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getPatientByHealthcarepartyAndIdentifier(hcPartyId: kotlin.String, id: kotlin.String, system: kotlin.String?) : PatientDto?  {
        val localVariableConfig = getPatientByHealthcarepartyAndIdentifierRequestConfig(hcPartyId = hcPartyId, id = id, system = system)

        return request<Unit, PatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getPatientByHealthcarepartyAndIdentifier
    *
    * @param hcPartyId  
    * @param id  
    * @param system  (optional)
    * @return RequestConfig
    */
    fun getPatientByHealthcarepartyAndIdentifierRequestConfig(hcPartyId: kotlin.String, id: kotlin.String, system: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (system != null) {
                    put("system", listOf(system.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/{hcPartyId}/{id}".replace("{"+"hcPartyId"+"}", "$hcPartyId").replace("{"+"id"+"}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get the patient (identified by patientId) hcparty keys. Those keys are AES keys (encrypted) used to share information between HCPs and a patient.
    * This endpoint is used to recover all keys that have already been created and that can be used to share information with this patient. It returns a map with the following structure: ID of the owner of the encrypted AES key -&gt; encrypted AES key. The returned encrypted AES keys will have to be decrypted using the patient&#39;s private key.
    * @param patientId The patient Id for which information is shared 
    * @return kotlin.String
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getPatientHcPartyKeysForDelegate(patientId: kotlin.String) : kotlin.String?  {
        val localVariableConfig = getPatientHcPartyKeysForDelegateRequestConfig(patientId = patientId)

        return request<Unit, kotlin.String>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getPatientHcPartyKeysForDelegate
    *
    * @param patientId The patient Id for which information is shared 
    * @return RequestConfig
    */
    fun getPatientHcPartyKeysForDelegateRequestConfig(patientId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/{patientId}/keys".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get patients by id
    * It gets patient administrative data.
    * @param listOfIdsDto  
    * @return kotlin.collections.List<PatientDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getPatients(listOfIdsDto: ListOfIdsDto) : kotlin.collections.List<PatientDto>?  {
        val localVariableConfig = getPatientsRequestConfig(listOfIdsDto = listOfIdsDto)

        return request<ListOfIdsDto, kotlin.collections.List<PatientDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation getPatients
    *
    * @param listOfIdsDto  
    * @return RequestConfig
    */
    fun getPatientsRequestConfig(listOfIdsDto: ListOfIdsDto) : RequestConfig<ListOfIdsDto> {
        val localVariableBody = listOfIdsDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/patient/byIds",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Find deleted patients
    * Returns a list of deleted patients, within the specified time period, if any.
    * @param startDate Filter deletions after this date (unix epoch), included (optional)
    * @param endDate Filter deletions before this date (unix epoch), included (optional)
    * @param desc Descending (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @return PaginatedListPatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listDeletedPatients(startDate: kotlin.Long?, endDate: kotlin.Long?, desc: kotlin.Boolean?, startDocumentId: kotlin.String?, limit: kotlin.Int?) : PaginatedListPatientDto?  {
        val localVariableConfig = listDeletedPatientsRequestConfig(startDate = startDate, endDate = endDate, desc = desc, startDocumentId = startDocumentId, limit = limit)

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation listDeletedPatients
    *
    * @param startDate Filter deletions after this date (unix epoch), included (optional)
    * @param endDate Filter deletions before this date (unix epoch), included (optional)
    * @param desc Descending (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @return RequestConfig
    */
    fun listDeletedPatientsRequestConfig(startDate: kotlin.Long?, endDate: kotlin.Long?, desc: kotlin.Boolean?, startDocumentId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (startDate != null) {
                    put("startDate", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("endDate", listOf(endDate.toString()))
                }
                if (desc != null) {
                    put("desc", listOf(desc.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/deleted/by_date",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Find deleted patients
    * Returns a list of deleted patients, by name and/or firstname prefix, if any.
    * @param firstName First name prefix (optional)
    * @param lastName Last name prefix (optional)
    * @return kotlin.collections.List<PatientDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listDeletedPatientsByName(firstName: kotlin.String?, lastName: kotlin.String?) : kotlin.collections.List<PatientDto>?  {
        val localVariableConfig = listDeletedPatientsByNameRequestConfig(firstName = firstName, lastName = lastName)

        return request<Unit, kotlin.collections.List<PatientDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation listDeletedPatientsByName
    *
    * @param firstName First name prefix (optional)
    * @param lastName Last name prefix (optional)
    * @return RequestConfig
    */
    fun listDeletedPatientsByNameRequestConfig(firstName: kotlin.String?, lastName: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (firstName != null) {
                    put("firstName", listOf(firstName.toString()))
                }
                if (lastName != null) {
                    put("lastName", listOf(lastName.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/deleted/by_name",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * List patients that have been merged towards another patient 
    * Returns a list of patients that have been merged after the provided date
    * @param date  
    * @return kotlin.collections.List<PatientDto>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listOfMergesAfter(date: kotlin.Long) : kotlin.collections.List<PatientDto>?  {
        val localVariableConfig = listOfMergesAfterRequestConfig(date = date)

        return request<Unit, kotlin.collections.List<PatientDto>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation listOfMergesAfter
    *
    * @param date  
    * @return RequestConfig
    */
    fun listOfMergesAfterRequestConfig(date: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/merges/{date}".replace("{"+"date"+"}", "$date"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * List patients that have been modified after the provided date
    * Returns a list of patients that have been modified after the provided date
    * @param date  
    * @param startKey The start key for pagination the date of the first element of the new page (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @return PaginatedListPatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listOfPatientsModifiedAfter(date: kotlin.Long, startKey: kotlin.Long?, startDocumentId: kotlin.String?, limit: kotlin.Int?) : PaginatedListPatientDto?  {
        val localVariableConfig = listOfPatientsModifiedAfterRequestConfig(date = date, startKey = startKey, startDocumentId = startDocumentId, limit = limit)

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation listOfPatientsModifiedAfter
    *
    * @param date  
    * @param startKey The start key for pagination the date of the first element of the new page (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @return RequestConfig
    */
    fun listOfPatientsModifiedAfterRequestConfig(date: kotlin.Long, startKey: kotlin.Long?, startDocumentId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/modifiedAfter/{date}".replace("{"+"date"+"}", "$date"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * List patients for a specific HcParty
    * Returns a list of patients along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
    * @param hcPartyId Healthcare party id (optional)
    * @param sortField Optional value for sorting results by a given field (&#39;name&#39;, &#39;ssin&#39;, &#39;dateOfBirth&#39;). Specifying this deactivates filtering (optional)
    * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @param sortDirection Optional value for providing a sorting direction (&#39;asc&#39;, &#39;desc&#39;). Set to &#39;asc&#39; by default. (optional, default to "asc")
    * @return PaginatedListPatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listPatients(hcPartyId: kotlin.String?, sortField: kotlin.String?, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?, sortDirection: kotlin.String?) : PaginatedListPatientDto?  {
        val localVariableConfig = listPatientsRequestConfig(hcPartyId = hcPartyId, sortField = sortField, startKey = startKey, startDocumentId = startDocumentId, limit = limit, sortDirection = sortDirection)

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation listPatients
    *
    * @param hcPartyId Healthcare party id (optional)
    * @param sortField Optional value for sorting results by a given field (&#39;name&#39;, &#39;ssin&#39;, &#39;dateOfBirth&#39;). Specifying this deactivates filtering (optional)
    * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @param sortDirection Optional value for providing a sorting direction (&#39;asc&#39;, &#39;desc&#39;). Set to &#39;asc&#39; by default. (optional, default to "asc")
    * @return RequestConfig
    */
    fun listPatientsRequestConfig(hcPartyId: kotlin.String?, sortField: kotlin.String?, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?, sortDirection: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (hcPartyId != null) {
                    put("hcPartyId", listOf(hcPartyId.toString()))
                }
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sortDirection != null) {
                    put("sortDirection", listOf(sortDirection.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * List patients for a specific HcParty or for the current HcParty 
    * Returns a list of patients along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
    * @param hcPartyId  
    * @param sortField Optional value for sorting results by a given field (&#39;name&#39;, &#39;ssin&#39;, &#39;dateOfBirth&#39;). Specifying this deactivates filtering (optional)
    * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @param sortDirection Optional value for providing a sorting direction (&#39;asc&#39;, &#39;desc&#39;). Set to &#39;asc&#39; by default. (optional)
    * @return PaginatedListPatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listPatientsByHcParty(hcPartyId: kotlin.String, sortField: kotlin.String?, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?, sortDirection: kotlin.String?) : PaginatedListPatientDto?  {
        val localVariableConfig = listPatientsByHcPartyRequestConfig(hcPartyId = hcPartyId, sortField = sortField, startKey = startKey, startDocumentId = startDocumentId, limit = limit, sortDirection = sortDirection)

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation listPatientsByHcParty
    *
    * @param hcPartyId  
    * @param sortField Optional value for sorting results by a given field (&#39;name&#39;, &#39;ssin&#39;, &#39;dateOfBirth&#39;). Specifying this deactivates filtering (optional)
    * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @param sortDirection Optional value for providing a sorting direction (&#39;asc&#39;, &#39;desc&#39;). Set to &#39;asc&#39; by default. (optional)
    * @return RequestConfig
    */
    fun listPatientsByHcPartyRequestConfig(hcPartyId: kotlin.String, sortField: kotlin.String?, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?, sortDirection: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sortDirection != null) {
                    put("sortDirection", listOf(sortDirection.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/hcParty/{hcPartyId}".replace("{"+"hcPartyId"+"}", "$hcPartyId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * List patients by pages for a specific HcParty
    * Returns a list of patients along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
    * @param hcPartyId Healthcare party id 
    * @param startKey The page first id (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Page size (optional)
    * @return PaginatedListString
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listPatientsIds(hcPartyId: kotlin.String, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?) : PaginatedListString?  {
        val localVariableConfig = listPatientsIdsRequestConfig(hcPartyId = hcPartyId, startKey = startKey, startDocumentId = startDocumentId, limit = limit)

        return request<Unit, PaginatedListString>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation listPatientsIds
    *
    * @param hcPartyId Healthcare party id 
    * @param startKey The page first id (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Page size (optional)
    * @return RequestConfig
    */
    fun listPatientsIdsRequestConfig(hcPartyId: kotlin.String, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                put("hcPartyId", listOf(hcPartyId.toString()))
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/idsPages",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * List patients of a specific HcParty or of the current HcParty 
    * Returns a list of patients along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
    * @param hcPartyId  
    * @param sortField Optional value for sorting results by a given field (&#39;name&#39;, &#39;ssin&#39;, &#39;dateOfBirth&#39;). Specifying this deactivates filtering (optional)
    * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @param sortDirection Optional value for providing a sorting direction (&#39;asc&#39;, &#39;desc&#39;). Set to &#39;asc&#39; by default. (optional, default to "asc")
    * @return PaginatedListPatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listPatientsOfHcParty(hcPartyId: kotlin.String, sortField: kotlin.String?, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?, sortDirection: kotlin.String?) : PaginatedListPatientDto?  {
        val localVariableConfig = listPatientsOfHcPartyRequestConfig(hcPartyId = hcPartyId, sortField = sortField, startKey = startKey, startDocumentId = startDocumentId, limit = limit, sortDirection = sortDirection)

        return request<Unit, PaginatedListPatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation listPatientsOfHcParty
    *
    * @param hcPartyId  
    * @param sortField Optional value for sorting results by a given field (&#39;name&#39;, &#39;ssin&#39;, &#39;dateOfBirth&#39;). Specifying this deactivates filtering (optional)
    * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
    * @param startDocumentId A patient document ID (optional)
    * @param limit Number of rows (optional)
    * @param sortDirection Optional value for providing a sorting direction (&#39;asc&#39;, &#39;desc&#39;). Set to &#39;asc&#39; by default. (optional, default to "asc")
    * @return RequestConfig
    */
    fun listPatientsOfHcPartyRequestConfig(hcPartyId: kotlin.String, sortField: kotlin.String?, startKey: kotlin.String?, startDocumentId: kotlin.String?, limit: kotlin.Int?, sortDirection: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (sortField != null) {
                    put("sortField", listOf(sortField.toString()))
                }
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sortDirection != null) {
                    put("sortDirection", listOf(sortDirection.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v1/patient/ofHcParty/{hcPartyId}".replace("{"+"hcPartyId"+"}", "$hcPartyId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Get ids of patients matching the provided filter for the current user (HcParty) 
    * 
    * @param abstractFilterDtoPatient  
    * @return kotlin.collections.List<kotlin.String>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun matchPatientsBy(abstractFilterDtoPatient: io.icure.kraken.client.models.filter.AbstractFilterDto<io.icure.kraken.client.models.PatientDto>) : kotlin.collections.List<kotlin.String>?  {
        val localVariableConfig = matchPatientsByRequestConfig(abstractFilterDtoPatient = abstractFilterDtoPatient)

        return request<io.icure.kraken.client.models.filter.AbstractFilterDto<io.icure.kraken.client.models.PatientDto>, kotlin.collections.List<kotlin.String>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation matchPatientsBy
    *
    * @param abstractFilterDtoPatient  
    * @return RequestConfig
    */
    fun matchPatientsByRequestConfig(abstractFilterDtoPatient: io.icure.kraken.client.models.filter.AbstractFilterDto<io.icure.kraken.client.models.PatientDto>) : RequestConfig<io.icure.kraken.client.models.filter.AbstractFilterDto<io.icure.kraken.client.models.PatientDto>> {
        val localVariableBody = abstractFilterDtoPatient
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/patient/match",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Merge a series of patients into another patient
    * 
    * @param toId  
    * @param fromIds  
    * @return PatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun mergeInto(toId: kotlin.String, fromIds: kotlin.String) : PatientDto?  {
        val localVariableConfig = mergeIntoRequestConfig(toId = toId, fromIds = fromIds)

        return request<Unit, PatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation mergeInto
    *
    * @param toId  
    * @param fromIds  
    * @return RequestConfig
    */
    fun mergeIntoRequestConfig(toId: kotlin.String, fromIds: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v1/patient/mergeInto/{toId}/from/{fromIds}".replace("{"+"toId"+"}", "$toId").replace("{"+"fromIds"+"}", "$fromIds"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Modify a patient
    * No particular return value. It&#39;s just a message.
    * @param patientDto  
    * @return PatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyPatient(patientDto: PatientDto) : PatientDto?  {
        val localVariableConfig = modifyPatientRequestConfig(patientDto = patientDto)

        return request<PatientDto, PatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation modifyPatient
    *
    * @param patientDto  
    * @return RequestConfig
    */
    fun modifyPatientRequestConfig(patientDto: PatientDto) : RequestConfig<PatientDto> {
        val localVariableBody = patientDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v1/patient",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Set a patient referral doctor
    * 
    * @param patientId  
    * @param referralId The referal id. Accepts &#39;none&#39; for referral removal. 
    * @param start Optional value for start of referral (optional)
    * @param end Optional value for end of referral (optional)
    * @return PatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyPatientReferral(patientId: kotlin.String, referralId: kotlin.String, start: kotlin.Long?, end: kotlin.Long?) : PatientDto?  {
        val localVariableConfig = modifyPatientReferralRequestConfig(patientId = patientId, referralId = referralId, start = start, end = end)

        return request<Unit, PatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation modifyPatientReferral
    *
    * @param patientId  
    * @param referralId The referal id. Accepts &#39;none&#39; for referral removal. 
    * @param start Optional value for start of referral (optional)
    * @param end Optional value for end of referral (optional)
    * @return RequestConfig
    */
    fun modifyPatientReferralRequestConfig(patientId: kotlin.String, referralId: kotlin.String, start: kotlin.Long?, end: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (end != null) {
                    put("end", listOf(end.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v1/patient/{patientId}/referral/{referralId}".replace("{"+"patientId"+"}", "$patientId").replace("{"+"referralId"+"}", "$referralId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Delegates a patients to a healthcare party
    * It delegates a patient to a healthcare party (By current healthcare party). A modified patient with new delegation gets returned.
    * @param patientId  
    * @param delegationDto  
    * @return PatientDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun newPatientDelegations(patientId: kotlin.String, delegationDto: kotlin.collections.List<DelegationDto>) : PatientDto?  {
        val localVariableConfig = newPatientDelegationsRequestConfig(patientId = patientId, delegationDto = delegationDto)

        return request<kotlin.collections.List<DelegationDto>, PatientDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation newPatientDelegations
    *
    * @param patientId  
    * @param delegationDto  
    * @return RequestConfig
    */
    fun newPatientDelegationsRequestConfig(patientId: kotlin.String, delegationDto: kotlin.collections.List<DelegationDto>) : RequestConfig<kotlin.collections.List<DelegationDto>> {
        val localVariableBody = delegationDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/patient/{patientId}/delegate".replace("{"+"patientId"+"}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * Register a patient
    * Register a new patient into the system
    * @param hcPartyId  
    * @param groupId  
    * @param patientDto  
    * @param useShortToken  (optional)
    * @return PatientRegistrationSuccessDto
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun registerPatient(hcPartyId: kotlin.String, groupId: kotlin.String, patientDto: PatientDto, useShortToken: kotlin.Boolean?) : PatientRegistrationSuccessDto?  {
        val localVariableConfig = registerPatientRequestConfig(hcPartyId = hcPartyId, groupId = groupId, patientDto = patientDto, useShortToken = useShortToken)

        return request<PatientDto, PatientRegistrationSuccessDto>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation registerPatient
    *
    * @param hcPartyId  
    * @param groupId  
    * @param patientDto  
    * @param useShortToken  (optional)
    * @return RequestConfig
    */
    fun registerPatientRequestConfig(hcPartyId: kotlin.String, groupId: kotlin.String, patientDto: PatientDto, useShortToken: kotlin.Boolean?) : RequestConfig<PatientDto> {
        val localVariableBody = patientDto
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
            .apply {
                if (useShortToken != null) {
                    put("useShortToken", listOf(useShortToken.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v1/patient/register/forHcp/{hcPartyId}/inGroup/{groupId}".replace("{"+"hcPartyId"+"}", "$hcPartyId").replace("{"+"groupId"+"}", "$groupId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
    * undelete previously deleted patients
    * Response is an array containing the ID of undeleted patient..
    * @param patientIds  
    * @return kotlin.collections.List<DocIdentifier>
    * @throws UnsupportedOperationException If the API returns an informational or redirection response
    * @throws ClientException If the API returns a client error response
    * @throws ServerException If the API returns a server error response
    */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun undeletePatient(patientIds: kotlin.String) : kotlin.collections.List<DocIdentifier>?  {
        val localVariableConfig = undeletePatientRequestConfig(patientIds = patientIds)

        return request<Unit, kotlin.collections.List<DocIdentifier>>(
            localVariableConfig
        )
    }

    /**
    * To obtain the request config of the operation undeletePatient
    *
    * @param patientIds  
    * @return RequestConfig
    */
    fun undeletePatientRequestConfig(patientIds: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v1/patient/undelete/{patientIds}".replace("{"+"patientIds"+"}", "$patientIds"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
