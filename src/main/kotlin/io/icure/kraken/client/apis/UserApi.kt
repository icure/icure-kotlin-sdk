/**
 * iCure Data Stack API Documentation
 *
 * The iCure Data Stack Application API is the native interface to iCure.
 *
 * The version of the OpenAPI document: v2
 *
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */
package io.icure.kraken.client.apis

import io.icure.asyncjacksonhttpclient.net.web.WebClient
import io.icure.asyncjacksonhttpclient.netty.NettyWebClient
import io.icure.kraken.client.infrastructure.*
import io.icure.kraken.client.models.DocIdentifier
import io.icure.kraken.client.models.PaginatedListUserDto
import org.taktik.icure.services.external.rest.v2.dto.PropertyStubDto
import io.icure.kraken.client.security.AuthProvider
import io.icure.kraken.client.security.NoAuthProvider
import kotlinx.coroutines.ExperimentalCoroutinesApi
import org.taktik.icure.services.external.rest.v2.dto.UserDto
import org.taktik.icure.services.external.rest.v2.dto.UserGroupDto
import org.taktik.icure.services.external.rest.v2.dto.security.TokenWithGroupDto
import java.net.URLEncoder
import java.util.*
import javax.inject.Named

@Named
@ExperimentalStdlibApi
@ExperimentalCoroutinesApi
class UserApi(
    basePath: String = defaultBasePath,
    webClient: WebClient = NettyWebClient(),
    authProvider: AuthProvider = NoAuthProvider()
) : ApiClient(basePath, webClient, authProvider) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty("io.icure.kraken.client.baseUrl", "https://kraken.icure.dev")
        }
    }

    /**
     * Assign a healthcare party ID to current user
     * UserDto gets returned.
     * @param healthcarePartyId
     * @return UserDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun assignHealthcareParty(healthcarePartyId: String): UserDto {
        val localVariableConfig = assignHealthcarePartyRequestConfig(healthcarePartyId = healthcarePartyId)

        return request<Unit, UserDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation assignHealthcareParty
     *
     * @param healthcarePartyId
     * @return RequestConfig
     */
    fun assignHealthcarePartyRequestConfig(healthcarePartyId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/user/current/hcparty/{healthcarePartyId}".replace(
                "{" + "healthcarePartyId" + "}",
                URLEncoder.encode(healthcarePartyId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     *
     *
     * @param password
     * @return kotlin.Boolean
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun checkPassword(password: String): Boolean {
        val localVariableConfig = checkPasswordRequestConfig(password = password)

        return request<Unit, Boolean>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation checkPassword
     *
     * @param password
     * @return RequestConfig
     */
    fun checkPasswordRequestConfig(password: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null
        password.apply { localVariableHeaders["password"] = this }

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/user/checkPassword",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Check token validity
     *
     * @param userId
     * @param token
     * @return kotlin.Boolean
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun checkTokenValidity(userId: String, token: String): Boolean {
        val localVariableConfig = checkTokenValidityRequestConfig(userId = userId, token = token)

        return request<Unit, Boolean>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation checkTokenValidity
     *
     * @param userId
     * @param token
     * @return RequestConfig
     */
    fun checkTokenValidityRequestConfig(userId: String, token: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null
        token.apply { localVariableHeaders["token"] = this }

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/user/token/{userId}".replace(
                "{" + "userId" + "}",
                URLEncoder.encode(userId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create a user
     * Create a user. HealthcareParty ID should be set. Email or Login have to be set. If login hasn&#39;t been set, Email will be used for Login instead.
     * @param userDto
     * @return UserDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createUser(userDto: UserDto): UserDto {
        val localVariableConfig = createUserRequestConfig(userDto = userDto)

        return request<UserDto, UserDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation createUser
     *
     * @param userDto
     * @return RequestConfig
     */
    fun createUserRequestConfig(userDto: UserDto): RequestConfig<UserDto> {
        // val localVariableBody = userDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = userDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/user",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Create a user
     * Create a user. HealthcareParty ID should be set. Email has to be set and the Login has to be null. On server-side, Email will be used for Login.
     * @param groupId
     * @param userDto
     * @return UserDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createUserInGroup(groupId: String, userDto: UserDto): UserDto {
        val localVariableConfig = createUserInGroupRequestConfig(groupId = groupId, userDto = userDto)

        return request<UserDto, UserDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation createUserInGroup
     *
     * @param groupId
     * @param userDto
     * @return RequestConfig
     */
    fun createUserInGroupRequestConfig(groupId: String, userDto: UserDto): RequestConfig<UserDto> {
        // val localVariableBody = userDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = userDto

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/user/inGroup/{groupId}".replace(
                "{" + "groupId" + "}",
                URLEncoder.encode(groupId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete a User based on his/her ID.
     * Delete a User based on his/her ID. The return value is an array containing the ID of deleted user.
     * @param userId
     * @return DocIdentifier
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteUser(userId: String): DocIdentifier {
        val localVariableConfig = deleteUserRequestConfig(userId = userId)

        return request<Unit, DocIdentifier>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation deleteUser
     *
     * @param userId
     * @return RequestConfig
     */
    fun deleteUserRequestConfig(userId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/rest/v2/user/{userId}".replace(
                "{" + "userId" + "}",
                URLEncoder.encode(userId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete a User based on his/her ID.
     * Delete a User based on his/her ID. The return value is an array containing the ID of deleted user.
     * @param groupId
     * @param userId
     * @return kotlin.Any
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteUserInGroup(groupId: String, userId: String): Any {
        val localVariableConfig = deleteUserInGroupRequestConfig(groupId = groupId, userId = userId)

        return request<Unit, Any>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation deleteUserInGroup
     *
     * @param groupId
     * @param userId
     * @return RequestConfig
     */
    fun deleteUserInGroupRequestConfig(groupId: String, userId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/rest/v2/user/inGroup/{groupId}/{userId}".replace(
                "{" + "groupId" + "}",
                URLEncoder.encode(groupId, Charsets.UTF_8)
            ).replace("{" + "userId" + "}", URLEncoder.encode(userId, Charsets.UTF_8)),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     *
     *
     * @param password
     * @return kotlin.String
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun encodePassword(password: String): String {
        val localVariableConfig = encodePasswordRequestConfig(password = password)

        return request<Unit, String>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation encodePassword
     *
     * @param password
     * @return RequestConfig
     */
    fun encodePasswordRequestConfig(password: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null
        password.apply { localVariableHeaders["password"] = this }

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/user/encodePassword",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Filter users for the current user (HcParty)
     * Returns a list of users along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
     * @param filterChainUser
     * @param startDocumentId A User document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListUserDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filterUsersBy(
        filterChainUser: io.icure.kraken.client.models.filter.chain.FilterChain<UserDto>,
        startDocumentId: String?,
        limit: Int?
    ): PaginatedListUserDto {
        val localVariableConfig = filterUsersByRequestConfig(
            filterChainUser = filterChainUser,
            startDocumentId = startDocumentId,
            limit = limit
        )

        return request<io.icure.kraken.client.models.filter.chain.FilterChain<UserDto>, PaginatedListUserDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation filterUsersBy
     *
     * @param filterChainUser
     * @param startDocumentId A User document ID (optional)
     * @param limit Number of rows (optional)
     * @return RequestConfig
     */
    fun filterUsersByRequestConfig(
        filterChainUser: io.icure.kraken.client.models.filter.chain.FilterChain<UserDto>,
        startDocumentId: String?,
        limit: Int?
    ): RequestConfig<io.icure.kraken.client.models.filter.chain.FilterChain<UserDto>> {
        // val localVariableBody = filterChainUser
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = filterChainUser

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/user/filter",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Filter users for the current user (HcParty) for a provided groupId
     * Returns a list of users along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.
     * @param groupId
     * @param filterChainUser
     * @param startDocumentId A User document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListUserDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun filterUsersInGroupBy(
        groupId: String,
        filterChainUser: io.icure.kraken.client.models.filter.chain.FilterChain<UserDto>,
        startDocumentId: String?,
        limit: Int?
    ): PaginatedListUserDto {
        val localVariableConfig = filterUsersInGroupByRequestConfig(
            groupId = groupId,
            filterChainUser = filterChainUser,
            startDocumentId = startDocumentId,
            limit = limit
        )

        return request<io.icure.kraken.client.models.filter.chain.FilterChain<UserDto>, PaginatedListUserDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation filterUsersInGroupBy
     *
     * @param groupId
     * @param filterChainUser
     * @param startDocumentId A User document ID (optional)
     * @param limit Number of rows (optional)
     * @return RequestConfig
     */
    fun filterUsersInGroupByRequestConfig(
        groupId: String,
        filterChainUser: io.icure.kraken.client.models.filter.chain.FilterChain<UserDto>,
        startDocumentId: String?,
        limit: Int?
    ): RequestConfig<io.icure.kraken.client.models.filter.chain.FilterChain<UserDto>> {
        // val localVariableBody = filterChainUser
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = filterChainUser

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/user/filter/inGroup/{groupId}".replace(
                "{" + "groupId" + "}",
                URLEncoder.encode(groupId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get the list of users by healthcare party id
     *
     * @param id
     * @return kotlin.collections.List<kotlin.String>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findByHcpartyId(id: String): List<String> {
        val localVariableConfig = findByHcpartyIdRequestConfig(id = id)

        return request<Unit, List<String>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation findByHcpartyId
     *
     * @param id
     * @return RequestConfig
     */
    fun findByHcpartyIdRequestConfig(id: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/user/byHealthcarePartyId/{id}".replace(
                "{" + "id" + "}",
                URLEncoder.encode(id, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get the list of users by patient id
     *
     * @param id
     * @return kotlin.collections.List<kotlin.String>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun findByPatientId(id: String): List<String> {
        val localVariableConfig = findByPatientIdRequestConfig(id = id)

        return request<Unit, List<String>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation findByPatientId
     *
     * @param id
     * @return RequestConfig
     */
    fun findByPatientIdRequestConfig(id: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/user/byPatientId/{id}".replace(
                "{" + "id" + "}",
                URLEncoder.encode(id, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get Currently logged-in user session.
     * Get current user.
     * @return kotlin.String
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCurrentSession(): String {
        val localVariableConfig = getCurrentSessionRequestConfig()

        return request<Unit, String>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getCurrentSession
     *
     * @return RequestConfig
     */
    fun getCurrentSessionRequestConfig(): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "text/plain"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/user/session",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get presently logged-in user.
     * Get current user.
     * @return UserDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCurrentUser(): UserDto {
        val localVariableConfig = getCurrentUserRequestConfig()

        return request<Unit, UserDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getCurrentUser
     *
     * @return RequestConfig
     */
    fun getCurrentUserRequestConfig(): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/user/current",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get presently logged-in user.
     * Get current user.
     * @return kotlin.collections.List<UserGroupDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getMatchingUsers(): List<UserGroupDto> {
        val localVariableConfig = getMatchingUsersRequestConfig()

        return request<Unit, List<UserGroupDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getMatchingUsers
     *
     * @return RequestConfig
     */
    fun getMatchingUsersRequestConfig(): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/user/matches",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Request a new temporary token for authentication
     *
     * @param userId
     * @param key The token key. Only one instance of a token with a defined key can exist at the same time
     * @param tokenValidity The token validity in seconds (optional)
     * @return kotlin.String
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getToken(userId: String, key: String, tokenValidity: Long?): String {
        val localVariableConfig = getTokenRequestConfig(userId = userId, key = key, tokenValidity = tokenValidity)

        return request<Unit, String>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getToken
     *
     * @param userId
     * @param key The token key. Only one instance of a token with a defined key can exist at the same time
     * @param tokenValidity The token validity in seconds (optional)
     * @return RequestConfig
     */
    fun getTokenRequestConfig(
        userId: String,
        key: String,
        tokenValidity: Long?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (tokenValidity != null) {
                    put("tokenValidity", listOf(tokenValidity.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/user/token/{userId}/{key}".replace(
                "{" + "userId" + "}",
                URLEncoder.encode(userId, Charsets.UTF_8)
            ).replace("{" + "key" + "}", URLEncoder.encode(key, Charsets.UTF_8)),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Require a new temporary token for authentication inside all groups
     *
     * @param userIdentifier
     * @param key The token key. Only one instance of a token with a defined key can exist at the same time
     * @param token  (optional)
     * @param tokenValidity The token validity in seconds (optional)
     * @return kotlin.collections.List<TokenWithGroupDto>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getTokenInAllGroups(
        userIdentifier: String,
        key: String,
        token: String?,
        tokenValidity: Long?
    ): List<TokenWithGroupDto> {
        val localVariableConfig = getTokenInAllGroupsRequestConfig(
            userIdentifier = userIdentifier,
            key = key,
            token = token,
            tokenValidity = tokenValidity
        )

        return request<Unit, List<TokenWithGroupDto>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getTokenInAllGroups
     *
     * @param userIdentifier
     * @param key The token key. Only one instance of a token with a defined key can exist at the same time
     * @param token  (optional)
     * @param tokenValidity The token validity in seconds (optional)
     * @return RequestConfig
     */
    fun getTokenInAllGroupsRequestConfig(
        userIdentifier: String,
        key: String,
        token: String?,
        tokenValidity: Long?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (tokenValidity != null) {
                    put("tokenValidity", listOf(tokenValidity.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null
        token?.apply { localVariableHeaders["token"] = this }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/user/inAllGroups/token/{userIdentifier}/{key}".replace(
                "{" + "userIdentifier" + "}",
                URLEncoder.encode(userIdentifier, Charsets.UTF_8)
            ).replace("{" + "key" + "}", URLEncoder.encode(key, Charsets.UTF_8)),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Require a new temporary token for authentication inside provided group
     *
     * @param groupId
     * @param userId
     * @param key The token key. Only one instance of a token with a defined key can exist at the same time
     * @param token  (optional)
     * @param tokenValidity The token validity in seconds (optional)
     * @return kotlin.String
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getTokenInGroup(
        groupId: String,
        userId: String,
        key: String,
        token: String?,
        tokenValidity: Long?
    ): String {
        val localVariableConfig = getTokenInGroupRequestConfig(
            groupId = groupId,
            userId = userId,
            key = key,
            token = token,
            tokenValidity = tokenValidity
        )

        return request<Unit, String>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getTokenInGroup
     *
     * @param groupId
     * @param userId
     * @param key The token key. Only one instance of a token with a defined key can exist at the same time
     * @param token  (optional)
     * @param tokenValidity The token validity in seconds (optional)
     * @return RequestConfig
     */
    fun getTokenInGroupRequestConfig(
        groupId: String,
        userId: String,
        key: String,
        token: String?,
        tokenValidity: Long?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (tokenValidity != null) {
                    put("tokenValidity", listOf(tokenValidity.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null
        token?.apply { localVariableHeaders["token"] = this }

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/user/inGroup/{groupId}/token/{userId}/{key}".replace(
                "{" + "groupId" + "}",
                URLEncoder.encode(groupId, Charsets.UTF_8)
            ).replace("{" + "userId" + "}", URLEncoder.encode(userId, Charsets.UTF_8))
                .replace("{" + "key" + "}", URLEncoder.encode(key, Charsets.UTF_8)),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get a user by his ID
     * General information about the user
     * @param userId
     * @return UserDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getUser(userId: String): UserDto {
        val localVariableConfig = getUserRequestConfig(userId = userId)

        return request<Unit, UserDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getUser
     *
     * @param userId
     * @return RequestConfig
     */
    fun getUserRequestConfig(userId: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/user/{userId}".replace(
                "{" + "userId" + "}",
                URLEncoder.encode(userId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get a user by his Email/Login
     * General information about the user
     * @param email
     * @return UserDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getUserByEmail(email: String): UserDto {
        val localVariableConfig = getUserByEmailRequestConfig(email = email)

        return request<Unit, UserDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation getUserByEmail
     *
     * @param email
     * @return RequestConfig
     */
    fun getUserByEmailRequestConfig(email: String): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/user/byEmail/{email}".replace(
                "{" + "email" + "}",
                URLEncoder.encode(email, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List users with(out) pagination
     * Returns a list of users.
     * @param startKey An user email (optional)
     * @param startDocumentId An user document ID (optional)
     * @param limit Number of rows (optional)
     * @param skipPatients Filter out patient users (optional)
     * @return PaginatedListUserDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listUsersBy(
        startKey: String?,
        startDocumentId: String?,
        limit: Int?,
        skipPatients: Boolean?
    ): PaginatedListUserDto {
        val localVariableConfig = listUsersByRequestConfig(
            startKey = startKey,
            startDocumentId = startDocumentId,
            limit = limit,
            skipPatients = skipPatients
        )

        return request<Unit, PaginatedListUserDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listUsersBy
     *
     * @param startKey An user email (optional)
     * @param startDocumentId An user document ID (optional)
     * @param limit Number of rows (optional)
     * @param skipPatients Filter out patient users (optional)
     * @return RequestConfig
     */
    fun listUsersByRequestConfig(
        startKey: String?,
        startDocumentId: String?,
        limit: Int?,
        skipPatients: Boolean?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (skipPatients != null) {
                    put("skipPatients", listOf(skipPatients.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/user",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * List users with(out) pagination
     * Returns a list of users.
     * @param groupId
     * @param startKey An user login (optional)
     * @param startDocumentId An user document ID (optional)
     * @param limit Number of rows (optional)
     * @return PaginatedListUserDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listUsersInGroup(
        groupId: String,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?
    ): PaginatedListUserDto {
        val localVariableConfig = listUsersInGroupRequestConfig(
            groupId = groupId,
            startKey = startKey,
            startDocumentId = startDocumentId,
            limit = limit
        )

        return request<Unit, PaginatedListUserDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation listUsersInGroup
     *
     * @param groupId
     * @param startKey An user login (optional)
     * @param startDocumentId An user document ID (optional)
     * @param limit Number of rows (optional)
     * @return RequestConfig
     */
    fun listUsersInGroupRequestConfig(
        groupId: String,
        startKey: String?,
        startDocumentId: String?,
        limit: Int?
    ): RequestConfig<Unit> {
        // val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<String, List<String>>()
            .apply {
                if (startKey != null) {
                    put("startKey", listOf(startKey.toString()))
                }
                if (startDocumentId != null) {
                    put("startDocumentId", listOf(startDocumentId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = null

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/rest/v2/user/inGroup/{groupId}".replace(
                "{" + "groupId" + "}",
                URLEncoder.encode(groupId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get ids of healthcare party matching the provided filter for the current user (HcParty)
     *
     * @param abstractFilterDtoUser
     * @return kotlin.collections.List<kotlin.String>
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun matchUsersBy(abstractFilterDtoUser: io.icure.kraken.client.models.filter.AbstractFilterDto<UserDto>): List<String> {
        val localVariableConfig = matchUsersByRequestConfig(abstractFilterDtoUser = abstractFilterDtoUser)

        return request<io.icure.kraken.client.models.filter.AbstractFilterDto<UserDto>, List<String>>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation matchUsersBy
     *
     * @param abstractFilterDtoUser
     * @return RequestConfig
     */
    fun matchUsersByRequestConfig(abstractFilterDtoUser: io.icure.kraken.client.models.filter.AbstractFilterDto<UserDto>): RequestConfig<io.icure.kraken.client.models.filter.AbstractFilterDto<UserDto>> {
        // val localVariableBody = abstractFilterDtoUser
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = abstractFilterDtoUser

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/rest/v2/user/match",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Modify a User property
     * Modify a User properties based on his/her ID. The return value is the modified user.
     * @param userId
     * @param propertyStubDto  (optional)
     * @return UserDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyProperties(
        userId: String,
        propertyStubDto: List<PropertyStubDto>?
    ): UserDto {
        val localVariableConfig = modifyPropertiesRequestConfig(userId = userId, propertyStubDto = propertyStubDto)

        return request<List<PropertyStubDto>, UserDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation modifyProperties
     *
     * @param userId
     * @param propertyStubDto  (optional)
     * @return RequestConfig
     */
    fun modifyPropertiesRequestConfig(
        userId: String,
        propertyStubDto: List<PropertyStubDto>?
    ): RequestConfig<List<PropertyStubDto>> {
        // val localVariableBody = propertyStubDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = propertyStubDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/user/{userId}/properties".replace(
                "{" + "userId" + "}",
                URLEncoder.encode(userId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Modify a user.
     * No particular return value. It&#39;s just a message.
     * @param userDto
     * @return UserDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyUser(userDto: UserDto): UserDto {
        val localVariableConfig = modifyUserRequestConfig(userDto = userDto)

        return request<UserDto, UserDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation modifyUser
     *
     * @param userDto
     * @return RequestConfig
     */
    fun modifyUserRequestConfig(userDto: UserDto): RequestConfig<UserDto> {
        // val localVariableBody = userDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = userDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/user",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Modify a user.
     * No particular return value. It&#39;s just a message.
     * @param groupId
     * @param userDto
     * @return UserDto
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun modifyUserInGroup(groupId: String, userDto: UserDto): UserDto {
        val localVariableConfig = modifyUserInGroupRequestConfig(groupId = groupId, userDto = userDto)

        return request<UserDto, UserDto>(
            localVariableConfig
        )!!
    }

    /**
     * To obtain the request config of the operation modifyUserInGroup
     *
     * @param groupId
     * @param userDto
     * @return RequestConfig
     */
    fun modifyUserInGroupRequestConfig(groupId: String, userDto: UserDto): RequestConfig<UserDto> {
        // val localVariableBody = userDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "application/json")
        localVariableHeaders["Accept"] = "*/*"
        val localVariableBody = userDto

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/rest/v2/user/inGroup/{groupId}".replace(
                "{" + "groupId" + "}",
                URLEncoder.encode(groupId, Charsets.UTF_8)
            ),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

}
